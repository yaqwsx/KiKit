{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KiKit \u2013 Automation for KiCAD","text":"<p>KiKit is a Python library, KiCAD plugin and  a CLI tool to automate several tasks in a standard KiCAD workflow like:</p> <ul> <li>panelization of both, regular and oddly shaped, boards (see   examples)</li> <li>automated exporting manufacturing data based on manufacturer presets</li> <li>multi-board project in KiCAD</li> <li>building board presentation pages (see an example presentation page generated   by KiKit)</li> </ul>"},{"location":"#do-you-enjoy-kikit-or-does-it-save-you-time","title":"Do You Enjoy KiKit or Does It Save You Time?","text":"<p>Then definitely consider:</p> <ul> <li>supporting me on GitHub Sponsors</li> <li>or become my Patreon,</li> <li>or buy me a coffee: </li> </ul> <p>Your support will allow me to allocate time to properly maintain my projects like this.</p> <p>PS: Be sure to check out my other KiCAD &amp; PCB related projects:</p> <ul> <li>Pinion</li> <li>PcbDraw</li> <li>JlcParts</li> </ul>"},{"location":"#why-should-i-use-it","title":"Why Should I Use It?","text":"<p>Everything KiKit does, can also be done via Pcbnew in KiCAD. However, you have to do it manually. One of the common scenarios is the creation of panels. Most of the tutorials on the internet guide you to use the \"append board\" functionality of Pcbnew. However, this approach is labour-intensive, error-prone and whenever, you change the board, you have to do it again.</p> <p>With KiKit you just call a CLI command if you have a simple layout (e.g., a grid) or write few Python instructions like \"place board here\", \"add bridge here\", \"separate boards via mouse bites/v-cuts\" and you are done. The process is repeatable and actually much simpler than hand-drawing the panels. KiKit also allows you to easily export all the Gerbers in a single step.</p> <p>You can then write a Makefile and simply call <code>make</code> to get all your manufacturing data and board presentation pages.</p>"},{"location":"#feature-list","title":"Feature List","text":"<ul> <li>create panels by appending boards and pieces of substrate (bridges)</li> <li>supports board with arbitrary shapes</li> <li>easily create mouse-bites/V-CUTS</li> <li>compared to hand-creation of panels, your panels will pass DRC (as tracks from   different instances of the same board have distinct nets when using KiKit)</li> <li>if you have multiple boards in a single file, you can split them</li> <li>simplifying multi-board project in KiCAD</li> <li>automated export of gerbers and assembly data</li> <li>3D printed self-registering solder paste stencils</li> <li>steel stencils with alignment jig</li> <li>create powerfull shell scrips or Makefiles which automates your workflow...</li> <li>...or invoke the functionality via GUI in KiCAD.</li> </ul>"},{"location":"#how-to-use-it","title":"How To Use It?","text":"<p>Read the CLI documentation and the panelize documentation. Also don't miss the examples. There is also a quick not on how to use panelization action plugin. If you are interested in generating solder paste stencils, see Stencil documentation</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The project is supported by:</p> <ul> <li>My GitHub sponsors and</li> <li></li> </ul>"},{"location":"#kikit-is-broken-or-does-not-work-as-expected","title":"KiKit Is Broken or Does Not Work as Expected","text":"<p>Please, first check FAQ. If you have not found answer for your problem there, feel free to open an issue on GitHub.</p> <p>If you would like to have a feature in KiKit that is currently not on a roadmap, or if you need to prepare custom panelization script (e.g., multi-design panels, panels with specific arrangement), you can consider hiring me to do the job. Just reach out to me via e-mail and we can discuss further details.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>The project is supported by:</p> <ul> <li>My GitHub sponsors and</li> <li></li> </ul> <p>Thank you all!</p>"},{"location":"cli/","title":"KiKit CLI interface","text":"<p>KiKit offers a simple CLI interface to perform common tasks easily. You can obtain help of the interface by calling <code>kikit --help</code>.</p> <p>The interface is structured into nested commands. On the top level, there are the following commands available:</p> <ul> <li>drc: Validate design rules of the board</li> <li>export: Export KiCAD boards</li> <li>fab: Export complete manufacturing data for given fabrication houses</li> <li>modify: Modify board items</li> <li>panelize: Panelize boards</li> <li>present: Prepare board presentation</li> <li>separate: Separate a single board out of a multi-board design.</li> <li>stencil: Create solder paste stencils</li> </ul>"},{"location":"cli/#export-commands","title":"Export commands","text":"<ul> <li><code>kikit export gerber &lt;boardFile&gt; [&lt;outputDir&gt;]</code> - export gerber files of   <code>boardFile</code> to <code>outputDir</code>. If no dir is specified, a new one   <code>&lt;boardFile&gt;-gerbers</code> is created.</li> <li><code>kikit export dxf &lt;boardFile&gt; [&lt;outputDir&gt;]</code> - export board outline and paste   layers to DXF. The main use case for this command is making 3D printed solder   paste   stencils.</li> </ul>"},{"location":"cli/#panelize-commands","title":"Panelize commands","text":"<p>Read more in a separate documentation section or see a walkthrough.</p>"},{"location":"cli/#separate-commands","title":"Separate commands","text":"<p>Read more in a separate documentation section.</p>"},{"location":"cli/#stencil-commands","title":"Stencil commands","text":"<p>Read more in a separate documentation section.</p>"},{"location":"cli/#present-commands","title":"Present commands","text":"<ul> <li><code>kikit present boardpage --name &lt;pagename&gt; -d &lt;descriptionFile&gt; -b &lt;name   comment boadfile&gt; -r &lt;resource&gt; --template &lt;template&gt; --repository &lt;url&gt;   &lt;outputdir&gt;</code> - generate single webpage providing board preview and a   possibility to download board files (gerbers and sources). See an example of   such page.<ul> <li>The description is a path to a markdown file with the main page content.</li> <li>You can specify multiple resources via <code>-r</code> or <code>--resource</code>. Resources are   files which will be copied to the output directory. Useful for images   referred from description</li> <li>You can specify multiple boards via <code>-b</code> or <code>--board</code></li> <li>Template is an optional argument which is either a path to a custom template   or a name of built-in templates (currently, there is only one: <code>default</code>).   See template documentation for more information about   templates.</li> </ul> </li> </ul>"},{"location":"cli/#modify-commands","title":"Modify commands","text":"<ul> <li> <p><code>kikit modify references --show/--hide  --pattern   &lt;pattern&gt; &lt;board&gt;</code> hide or show all references on the board matching a regular   pattern.</p> </li> <li> <p><code>kikit modify values --show/--hide  --pattern   &lt;pattern&gt; &lt;board&gt;</code> is the same as above, just with footprint values.</p> </li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#kikit-throws-away-components-from-my-panel-how-can-i-prevent-it","title":"KiKit throws away components from my panel, how can I prevent it?","text":"<p>KiKit respects the KiCAD component selection criteria. When you specify an input rectangle, only the components that fully fit inside the input rectangle are selected. This however take in account both name and value labels.</p> <p>When you do not specify the source are explicitly, KiKit takes the board outline bounding box as the source area. Therefore, by default, components outside the board substrate are not copied to panel.</p> <p>Since version 1.1 this behavior, however, changes for footprints. KiKit decides whether to keep a footprint or not based on whether its origin fits inside the source area or not. For graphical items, the behavior remains the same. The reason for this change is that often footprints reach out beyond the board edge (e.g., connectors) and the users don't want to remove them. On the other hand, graphical items (e.g., texts or arrows towards the board) are purely for documentation purposes and thus, they shouldn't be included in the panelized design.</p> <p>Note that this is intended behavior; for once it is consistent with KiCAD behavior of user selection and also it allows to easily ignore surrounding comments and drawings in the board sheet (it makes no sense to have 12 same copies of the notes around the board).</p> <p>How to include the components? - specify the source area explicitly to include all your components - specify <code>tolerance: 20mm</code> for <code>source</code> (i.e., <code>--source 'tolerance: 20mm'</code>) to   enlarge the board outline bounding box. The default value is 1 mm.</p>"},{"location":"faq/#my-milled-slots-are-gone-how-can-i-preserve-them","title":"My milled slots are gone! How can I preserve them?","text":"<p>KiKit's <code>millradius</code> parameter from the <code>postprocess</code> section simulates the board outline milling by a tool with given radius. That means that it will round all inner corners. It is not a command to round just your tabs. That means if you specify a tool which diameter is larger than your slot, KiKit will remove the slot as such slot cannot be created with the tool.</p> <p>This is an intended behavior. The options is designed for you to check if your board can be manufactured with all the features you have in your board outline. There aren't many fabrication houses that support sharp inner corners as they cannot be milled but have to be e.g., broached, which is much more complicated and expensive setup.</p> <p>If you want to preserve your narrow internal slots: - don't specify <code>millradius</code> at all in the <code>postprocess</code> - specify smaller <code>millradius</code> but make sure that your fabrication house   supports such small tools.</p>"},{"location":"faq/#my-mouse-bites-are-inside-the-board-what-should-i-do-about-it","title":"My mouse bites are inside the board, what should I do about it?","text":"<p>KiKit's mouse bites offset specifies how much should be the mouse bites put inside the board. The recommended value is 0.25 mm (read about it in this blog post). Why is it so? When you break the tab, there will be rough edges. By putting the mouse bites inside the board, these rough edges won't be sticking outside the designed board outline. When you want to fit your board in a tight enclosure, you don't have to perform manual deburing. Since it is considered a good practice, KiKit makes this the positive direction so you don't have to put minus everywhere.</p> <p>If you don't want to put mouse bites inside your board, just specify zero or negative offset.</p>"},{"location":"faq/#i-have-board-with-no-spacing-but-some-v-cuts-are-missing","title":"I have board with no spacing, but some V-cuts are missing.","text":"<p>The default style of tabs (<code>spacing</code>) does not generate in such a case any tabs, and, therefore, not cuts. Please use tab style <code>full</code>.</p>"},{"location":"faq/#i-get-error-modulenotfounderror-no-module-named-pcbnew","title":"I get error <code>ModuleNotFoundError: No module named 'pcbnew'</code>","text":"<p>You probably installed KiKit via Windows command prompt, not KiCAD Command Prompt.</p>"},{"location":"faq/#i-would-like-to-make-a-panel-out-of-different-designs-but-there-is-no-such-option-in-help","title":"I would like to make a panel out of different designs, but there is no such option in help","text":"<p>KiKit supports such feature. But it is not available from CLI. You have to write a simple Python script describing the panel and use KiKit as a library. Also, please refer to the panelization documentation.</p> <p>If you wonder why is it in such way: there are infinitely many ways to panel your design. A single CLI/UI will not fit them all and also even for the simple cases, it would be enormous and painful to use. Much better idea is to use a language to specify the panel. But why reinvent the wheel and design a custom language when we can use Python? It integrates well with other tools and many people already know it.</p>"},{"location":"faq/#there-are-no-plugins-in-kicad","title":"There are no plugins in KiCAD!","text":"<p>You have to install them via KiCAD PCM. See the installation guide.</p>"},{"location":"faq/#how-do-i-run-kikit-with-kicad-nightly","title":"How do I run KiKit with KiCAD nightly?","text":"<p>See section \"Choosing KiCAD version\" in the installation guide. However, at the moment KiKit is incompatible with KiCAD 6.99.</p>"},{"location":"multiboard/","title":"Multiboard workflow","text":""},{"location":"multiboard/#multi-board-workflow-with-kikit","title":"Multi-board workflow with KiKit","text":"<p>KiCAD does not support multiple board per project, nor boards with shared schematics. However, with the following workflow, you can easily draw multiple boards with shared schematics and, e.g., easily ensure that tha board connectors match.</p> <p>The workflow is the following:</p> <p>First, draw a separate schematics sheet for each of your boards and propagate the pins on the inter-board connectors. E.g., in one of my project it looks like this:</p> <p></p> <p>I also place the corresponding connectors next to each other to illustrate that they connect. Then draw your board schematics as usual - with one exception. Do not use global power symbols nor global labels, use only local labels. This ensures that the power lines are separate for each board and DRC won't complain, that you have not connected the power between two board.</p> <p>Then, draw all your boards into a single board file side-by-side. See file resources/multiboard.kicad_pcb for a dead simple illustration. You can also draw lines that will help you align your boards' connectors.</p> <p>Before manufacturing, use KiKit to extract the boards into a separate board files via the <code>extract</code> command.</p> <p>This can be done in two ways:</p> <ul> <li>via bounding box selection</li> <li>via annotation</li> </ul> <p>We will show how to use it on resources/multiboard.kicad_pcb which looks like this:</p> <p></p>"},{"location":"multiboard/#bounding-box-selection","title":"Bounding box selection","text":"<p>Simply specify the top left and bottom right corner. Everything that fits fully inside it, will be included in the board. The command for separation of board A into a separate board file is:</p> <pre><code>kikit separate --source 'rectangle; tlx: 89mm; tly: 89mm; brx: 111mm; bry: 111mm' \\\n        multiboard.kicad_pcb board_a.kicad_pcb\n</code></pre> <p>After that, <code>board_a.kicad_pcb</code> will contain only a board A. Note that the <code>\\</code> is there for shell as we split our command into two lines.</p>"},{"location":"multiboard/#annotation","title":"Annotation","text":"<p>As you can see, the source file contains an annotation in the form of virtual footprints <code>kikit:Board</code>. You can place them into your document so that the arrow points to the board edge. Than you can use the reference of the annotation symbol for separation of the board. To separate board A simply invoke:</p> <pre><code>kikit separate --source 'annotation; ref: B1' \\\n    multiboard.kicad_pcb board_a.kicad_pcb\n</code></pre> <p>After that, <code>board_a.kicad_pcb</code> will contain only a board A. Note that the <code>\\</code> is there for shell as we split our command into two lines.</p>"},{"location":"multiboard/#about-panelization","title":"About panelization","text":"<p>Note that if panelize your boards, you don't have to separate your boards first; just use the <code>--source</code> with the panelization command.</p>"},{"location":"multiboard/#preserving-annotations","title":"Preserving annotations","text":"<p>When you use the separate command, KiKit preserves all annotations within the source bounding box. If you would like to strip the annotations, you can specify <code>--stripAnnotation</code> and KiKit will remove all annotations from the resulting board.</p>"},{"location":"present/","title":"Present","text":"<p>Present is a collection of functions providing various ways to present KiCAD boards. The main one is a simple page generator which can be used in continuous integration to build pages where your users and collagues can download the automatically generated panels.</p>"},{"location":"present/#requirements","title":"Requirements","text":"<p>In order to include PCB drawings in presentations you will need to install PcbDraw.</p>"},{"location":"present/#template-namepath-resolution","title":"Template name/path resolution","text":"<p>The template argument is either a name of a built-it template or a path to a directory with a user-defined template. During the name resolution the first test is for the user-defined template; i.e., check if the name provided by the user is a directory path and the directory contains the file <code>template.json</code>. If not, try to resolve the name as the name of the built-in template.</p>"},{"location":"present/#what-is-a-template","title":"What is a template?","text":"<p>A template is a directory containing template files. There is a single mandatory file common to all template types <code>template.json</code>. An example of such file follows:</p> <pre><code>{\n    \"type\": \"HtmlTemplate\",\n    \"resources\": [\"css/*.css\"]\n}\n</code></pre> <p>The key <code>type</code> specifies what kind of template it is. Currently, only <code>HtmlTemplate</code> is supported (see more info about them below). Then there is the list of <code>resources</code> which are glob patterns for resource files which are copied to the output directory when rendering the template.</p>"},{"location":"present/#htmltemplate","title":"HtmlTemplate","text":"<p>Expects an <code>index.html</code> file in the root of the template. This is Handlerbars template which receives the following dictionary on render:</p> <pre><code>\"repo\": self.repository,\n\"gitRev\": gitRev,\n\"gitRevShort\": gitRev[:7] if gitRev else None,\n\"datetime\": self.currentDateTime(),\n\"name\": self.name,\n\"boards\": self.boards,\n\"description\": self.description\n</code></pre> <p><code>boards</code> is a list of a dictionary with following keys:</p> <ul> <li><code>front</code> path to render of the front side</li> <li><code>back</code> path to render of the back side</li> <li><code>gerbers</code> path to archive with gerbers</li> <li><code>file</code> path to <code>kicad_pcb</code> file</li> </ul> <p>See the default template in <code>kikit/resources/present/templates/default</code> for a starting point for custom templates.</p>"},{"location":"stencil/","title":"Exporting Solder Paste Stencils","text":"<p>If you populate your boards using a reflow oven, you often need solder paste stencils. One of the inconveniences with stencils is that  you have to align them manually. It is not hard, but it takes some time and a little bit of practice &amp; tricks (e.g. to use other PCBs for stencil alignment).</p> <p>KiKit provides two ways to generate stencils:</p> <ul> <li>a 3D self-registering model of a stencil you can easily print on SLA printer,</li> <li>files for manufacturing steel stencils in a fabrication house with 3D printed   aligning jig.</li> </ul>"},{"location":"stencil/#special-options-for-both-types-of-stencils","title":"Special Options For Both Types of Stencils","text":"<p>KiKit allows you to ignore components from the stencil by specifying <code>--ignore</code> followed by a comma separated list of components' references to exclude. Pads of these components will not appear in the stencil. This is useful, when you do not want to populate all components.</p> <p>The second common option is <code>--cutout</code> followed by a comma separated lists of components' references. For these components, the stencil will contain a cutout based on the component courtyard. This is useful when you have already pre-populated board and you want to populate more components -- e.g., when your assembly house does not have a special IC and you populate it yourself and also, when you do a board repair.</p>"},{"location":"stencil/#3d-printed-stencils","title":"3D Printed Stencils","text":"<p>I wrote a blog post about the 3D printed self-registering stencils on my blog. These stencils are quick solution when you urgently need a stencil but probably they don't last long and might come with imperfections.</p> <p></p> <p></p> <p>To generate such stencil, just call: <pre><code>kikit stencil createprinted [parameters] &lt;boardFile&gt; &lt;outputDirectory&gt;\n</code></pre> where parameters is one of the following: <pre><code>--pcbthickness FLOAT    PCB thickness in mm\n--thickness FLOAT       Stencil thickness in mm. Defines amount of paste\n                        dispensed\n--framewidth FLOAT      Register frame width\n--ignore TEXT           Comma separated list of components references to\n                        exclude from the stencil\n--frameclearance FLOAT  Clearance for the stencil register in milimeters\n--enlargeholes FLOAT    Enlarge pad holes by x mm\n</code></pre></p> <p>KiKit will output two STL files representing bottom and top register to the specified directory. You can directly print these files. In theory, if you don't have small pads spacing, you could print them even on FDM machine, but I haven't tested it.</p>"},{"location":"stencil/#steel-stencils","title":"Steel Stencils","text":"<p>Many fabhouses offer you to create a custom stencil. However, it is pain to align them. Therefore, KiKit offers a functionality to automatically generate stencils which fit a simple 3D printed or lasercut alignment jig.</p> <p>The jig is available as Fusion 360 model, STEP or 3MF.It it designed to be cut from 3mm thick acrylic but you can also print it. You need 4 2mm pins, 8 M2 screws and that's it. The frame can be customized - there two parameters of the model, <code>frameWidth</code> and <code>frameHeight</code> which define the largest PCB it can accept. I usually use 100x100mm and 60x60mm.</p> <p>Then you issue the following command within KiKit: <pre><code>kikit stencil create  --jigsize 60 60 &lt;boardFile&gt; &lt;outputDir&gt;\n</code></pre> Note that there are more options for this command, see output of <code>kikit stencil create --help</code>.</p> <p>KiKit will produce 2 STL files for aligning the PCB and a zip file with gerbers for the manufacturer. When you order your stencil, let them make both top and bottom side on the same stencil. One tip for JLC PCB: set custom size of the stencil when you order it - then it fits into your package with your PCB and you don't have to pay for extra shipping.</p> <p>The stencil you receive should look like on the following picture. It has mouse bites so you can easily break it off to precise size. It also has mounting holes.</p> <p></p> <p>Once you break the stencils off, you mount them in the jig frame:</p> <p></p> <p>Then you print alignment parts for your board and mount in onto the jig using M2 screws:</p> <p></p> <p></p> <p>Then you just use 2mm pins to align the frame and you can apply the paste!</p> <p></p> <p>The acrylic jig is reusable - you just have to mount new alignment pieces and change the stencil.</p>"},{"location":"fabrication/intro/","title":"Fabrication","text":"<p>KiKit offers fully automatic export of all data required for fabrication of your designs. Since every fabrication house has different requirements on the design files (e.g., special names of gerber files, different requirements for assembly files) there is no \"universal exporter\" in KiKit. Instead, KiKit offers special command for each supported fabrication house.</p>"},{"location":"fabrication/intro/#common-options","title":"Common Options","text":"<p>All fab subcommands has a common invocation structure:</p> <pre><code>kikit fab &lt;fabhouse&gt; &lt;options&gt; &lt;sourceDir&gt; &lt;outputDir&gt;\n</code></pre> <p>All commands also support the following options:</p> <ul> <li><code>--drc\\--no-drc</code> (default <code>--drc</code>). Check for DRC violations before exporting   the files. With this options, you won't send a board that fails DRC to your   manufacturer.</li> <li><code>--nametemplate &lt;str&gt;</code>:  If you want to name your files differently, specify   this option. This option takes a string that should contain <code>{}</code>. This string   will be replaced by <code>gerber</code>, <code>pos</code> or <code>bom</code> in the out file names. The   extension is appended automatically. Variables in   text are also supported   eg: <code>{boardTitle}_rev{boardRevision}_{date}_{}</code>. The project variables are   available with the <code>user-</code> prefix; e.g., `MFR: {user-mfr}```</li> </ul> <p>Each of the fab command also take additional, manufacturer specific, options. See documentation for the individual manufacturer below:</p>"},{"location":"fabrication/intro/#currently-supported","title":"Currently Supported:","text":"<p>Note: click on the name of the manufacturer to see corresponding documentation:</p> <ul> <li>JLC PCB: board manufacturing, SMD assembly. https://jlcpcb.com/</li> <li>PCBWay: board manufacturing, assembly. https://www.pcbway.com/</li> <li>OSH Park: board manufacturing. https://oshpark.com/</li> <li>Neoden YY1: desktop PCB assembly. https://neodenusa.com/neoden-yy1-pick-place-machine</li> <li>OpenPNP: Open system for pick'n'place machines. https://openpnp.org/</li> </ul>"},{"location":"fabrication/intro/#adding-new-fabrication-houses","title":"Adding New Fabrication Houses","text":"<p>To add a new fabrication command you have to extend KiKit's source code. A rather basic knowledge of python is required to do so.</p> <p>Create a new file <code>kikit/fab/fabhousename.py</code> and implement a new command with the same name as the file. Then add the command to <code>kikit/fab/__init__.py</code>. The common functionality for all fabrication houses should be located in <code>kikit/fab/common.py</code>. You can use <code>kikit/fab/jlcpcb.py</code> for inspiration.</p> <p>Once you implement a support for new fabrication house, open a pull request on KiKit's GitHub page.</p>"},{"location":"fabrication/jlcpcb/","title":"Fabrication: JLC PCB","text":"<p>The basic usage of this exporter is: <pre><code>kikit fab jlcpcb [OPTIONS] BOARD OUTPUTDIR\n</code></pre></p> <p>When you run this command, you will find file <code>gerbers.zip</code> in <code>OUTPUTDIR</code>. This file can be directly uploaded to JLC PCB site. KiKit automatically detects the number of layers. If you would like to include the project name in the archive name, you can supply <code>--autoname</code></p> <p>If you want to name your files differently, you can specify <code>--nametemplate</code>. This option takes a string that should contain <code>{}</code>. This string will be replaced by <code>gerber</code>, <code>pos</code> or <code>bom</code> in the out file names. The extension is appended automatically.</p>"},{"location":"fabrication/jlcpcb/#assembly","title":"Assembly","text":"<p>If you would also like to use the SMD assembly service, you have to specify <code>--assembly</code> option and also provide the board <code>--schematic &lt;schematics_file&gt;</code>. KiKit will generate two extra files: <code>bom.csv</code> (bill of materials) and <code>pos.csv</code> (component placement). Use these two files when ordering the PCB assembly.</p> <p>The files above will include all components on the board. You can override the default field name with option <code>--field</code>. This option accepts a comma separated list of names. The first found field is used. This can be used, e.g., for configuration of the board via resistors. You can put field \"LCSC\" for all components, then add fields \"CFG1_LCSC\" and \"CFG2_LCSC\" for some components. Then invoke KiKit with option <code>--field CFG1_LCSC,LCSC</code> for configuration 1 or <code>--field CFG2_LCSC,LCSC</code> for configuration 2.</p> <p>You can exclude some of the components by specifying <code>--ignore &lt;comma separated list of references&gt;</code>. You can also specify component field with name <code>JLCPCB_IGNORE</code> (the value of the field does not matter) to exclude the component from assembly. Also, if a component misses the order code field, KiKit will show warning. When you pass option <code>--missingError</code>, KiKit will fail when there is a component with missing order code. This might be useful in case when you run KiKit in CI and you want to fail the build.</p> <p>Note that when you order SMD assembly for a panel, you should specify panelized board and the original schematics of a single board.</p>"},{"location":"fabrication/jlcpcb/#correction-of-the-footprint-position","title":"Correction of the Footprint Position","text":"<p>It is possible that orientation footprints in your SMD does not match the orientation of the components in the SMD assembly service. There are two solutions:</p> <ul> <li>correct the orientation in the library or</li> <li>apply KiKit's orientation corrections.</li> </ul> <p>The first option is not always feasible - e.g., when you use KiCAD's built-in libraries or you are preparing a board for multiple fabrication houses and each of them uses a different orientation.</p> <p>KiKit allows you to specify the origin and orientation correction of the position. The correction is specified by <code>JLCPCB_CORRECTION</code> field. The field value is a semicolon separated tuple: <code>&lt;X&gt;; &lt;Y&gt;; &lt;Rotation&gt;</code> with values in millimeters and degrees. You can read the XY corrections by hovering cursor over the intended origin in footprint editor and mark the coordinates. Note that first the rotation correction is applied, then the translation. Usually, you will need only the rotation correction.</p>"},{"location":"fabrication/jlcpcb/#using-corrections-to-configure-jumpers","title":"Using Corrections to Configure Jumpers","text":"<p>If your board features solder jumpers you can use the corrections to specify their default value. The solder jumper should be designed such it can fit a zero Ohm resistor in suitable size. Then specify an order code of the zero Ohm resistor for the jumper and adjust correction so it fits the default position.</p> <p>Note that you can specify multiple correction fields by <code>--corrections &lt;comma separated list of correction filed names&gt;</code>. The first found correction field is used. This allows you to keep several configuration of the solder jumpers in your design e.g., in fields <code>JLCPCB_CORRECTION_CFG_1</code> and <code>JLCPCB_CORRECTION_CFG_2</code>. Then you can simply change the board configuration by calling kikit with <code>--corrections JLCPCB_CORRECTION_CFG_1,JLCPCB_CORRECTION</code> or <code>--corrections JLCPCB_CORRECTION_CFG_2,JLCPCB_CORRECTION</code>.</p>"},{"location":"fabrication/neodenyy1/","title":"Fabrication: Neoden YY1","text":"<p>The basic usage of this exporter is: <pre><code>kikit fab neodenyy1 [OPTIONS] BOARD OUTPUTDIR\n</code></pre></p> <p>When you run this command, you will find file <code>top_pos.csv</code> and <code>bottom_pos.csv</code> in <code>OUTPUTDIR</code>. This file can be used in Neoden YY1. KiKit automatically detects the number of layers.</p> <p>If you want to name your files differently, you can specify <code>--nametemplate</code>. This option takes a string that should contain <code>{}</code>. This string will be replaced by <code>gerber</code>, <code>pos</code> or <code>bom</code> in the out file names. The extension is appended automatically.</p>"},{"location":"fabrication/neodenyy1/#assembly","title":"Assembly","text":"<p>For Neoden YY1 you must specify <code>--assembly</code> option and provide the board <code>--schematic &lt;schematics_file&gt;</code>. KiKit will generate files: <code>top_pos.csv</code> (top layer component placement) and <code>bottom_pos.csv</code> (bottom layer component placement). Use these two files to assembly PCB on machine.</p> <p>On Neoden YY1, the position origin must use the bottom left corner of the board edge.</p>"},{"location":"fabrication/neodenyy1/#correction-of-the-footprint-position","title":"Correction of the Footprint Position","text":"<p>It is possible that orientation footprints in your SMD does not match the orientation of the components in the SMD assembly service. There are two solutions:</p> <ul> <li>correct the orientation in the library or</li> <li>apply KiKit's orientation corrections.</li> </ul> <p>The first option is not always feasible - e.g., when you use KiCAD's built-in libraries or you are preparing a board for multiple fabrication houses and each of them uses a different orientation.</p> <p>KiKit allows you to specify the origin and orientation correction of the position. The correction is specified by <code>YY1_CORRECTION</code> field. The field value is a semicolon separated tuple: <code>&lt;X&gt;; &lt;Y&gt;; &lt;Rotation&gt;</code> with values in millimeters and degrees. You can read the XY corrections by hovering cursor over the intended origin in footprint editor and mark the coordinates. Note that first the rotation correction is applied, then the translation. Usually, you will need only the rotation correction.</p>"},{"location":"fabrication/openpnp/","title":"Fabrication: OpenPNP","text":"<p>The basic usage of this exporter is: <pre><code>kikit fab openpn [OPTIONS] BOARD OUTPUTDIR\n</code></pre></p> <p>This exporter creates a single file <code>components.pos</code> that mimics KiCAD native <code>.pos</code> output. However, unlike KiCAD, it adds a unique identifier to component references to ensure they are unique (in the case of panels).</p>"},{"location":"fabrication/oshpark/","title":"Fabrication: OSH Park","text":"<p>The basic usage of this exporter is: <pre><code>kikit fab oshpark [OPTIONS] BOARD OUTPUTDIR\n</code></pre></p> <p>When you run this command, you will find <code>gerbers.zip</code> in <code>OUTPUTDIR</code>. This file can be directly uploaded to the OSH Park site. KiKit automatically detects the number of layers.</p> <p>If you want to name your files differently, you can specify <code>--nametemplate</code>. The extension is appended automatically.</p>"},{"location":"fabrication/pcbway/","title":"Fabrication: PCBWay","text":"<p>The basic usage of this exporter is: <pre><code>kikit fab pcbway [OPTIONS] BOARD OUTPUTDIR\n</code></pre></p> <p>When you run this command, you will find file <code>gerbers.zip</code> in <code>OUTPUTDIR</code>. This file can be directly uploaded to the PCBWay site. KiKit automatically detects the number of layers.</p> <p>If you want to name your files differently, you can specify <code>--nametemplate</code>. For detailed description of this option, see JLC PCB documentation.</p>"},{"location":"fabrication/pcbway/#assembly","title":"Assembly","text":"<p>If you would also like to use the SMD assembly service, you have to specify <code>--assembly</code> option and also provide the board <code>--schematic &lt;schematics_file&gt;</code>. KiKit will generate two extra files: <code>bom.csv</code> (bill of materials) and <code>pos.csv</code> (component placement). Use these two files when ordering the PCB assembly.</p> <p>The files above will include all components on the board by default, except footprints having the attribute virtual set. You should provide the \"Manufacturer\" and \"PartNumber\" Fields for each component, where PartNumber refers to the manufacturers part number (and can safely contain non-digit characters). If the \"Description\" field is present, this value will be inserted in the \"Value/Description\" column in the BOM, otherwise the value of the component. It is recommended to provide no description for capacitors, resistors, and inductors, so that the value is inserted into the BOM for them. PCBWay also requires the soldering type (SMD, thru-hole, ...) to be specified. Any footprint only having SMD pads will be considered as \"SMD\", everything else as \"thru-hole\". You can manually overwrite the type by adding a \"Type\" field to the component. For the footprint column of the BOM the KiCad footprint name is used by default. Add a \"FootprintPCBWay\" field to overwrite this in the BOM list for a more human readable footprint name, if you want. Finally, notes or assembly instructions can be added using the \"Notes\" field.</p> <p>You can exclude some of the components by specifying <code>--ignore &lt;comma separated list of references&gt;</code>. When you pass option <code>--missingError</code>, KiKit will fail when there is a component with missing manufacturer and/or part number. This might be useful in case when you run KiKit in CI and you want to fail the build.</p> <p>Note that when you order assembly for a panel, you should specify panelized board and the original schematics of a single board. Use the <code>--nBoards</code> parameter to specify the number of boards in the panel. The quantity column is generated by multiplying this number with the number of references in each row.</p>"},{"location":"fabrication/pcbway/#correction-of-the-footprint-position","title":"Correction of the Footprint Position","text":"<p>It is possible that orientation footprints in your SMD does not match the orientation of the components in the SMD assembly service. There are two solutions:</p> <ul> <li>correct the orientation in the library or</li> <li>apply KiKit's orientation corrections.</li> </ul> <p>The first option is not always feasible - e.g., when you use KiCAD's built-in libraries or you are preparing a board for multiple fabrication houses and each of them uses a different orientation.</p> <p>KiKit allows you to specify the origin and orientation correction of the position. The correction is specified by <code>PCBWAY_CORRECTION</code> field. The field value is a semicolon separated tuple: <code>&lt;X&gt;; &lt;Y&gt;; &lt;Rotation&gt;</code> with values in millimeters and degrees. You can read the XY corrections by hovering cursor over the intended origin in footprint editor and mark the coordinates. Note that first the rotation correction is applied, then the translation. Usually, you will need only the rotation correction.</p>"},{"location":"fabrication/pcbway/#using-corrections-to-configure-jumpers","title":"Using Corrections to Configure Jumpers","text":"<p>If your board features solder jumpers you can use the corrections to specify their default value. The solder jumper should be designed such it can fit a zero Ohm resistor in suitable size. Then specify an order code of the zero Ohm resistor for the jumper and adjust correction so it fits the default position.</p> <p>Note that you can specify multiple correction fields by <code>--corrections &lt;comma separated list of correction filed names&gt;</code>. The first found correction field is used. This allows you to keep several configuration of the solder jumpers in your design e.g., in fields <code>PCBWAY_CORRECTION_CFG_1</code> and <code>PCBWAY_CORRECTION_CFG_2</code>. Then you can simply change the board configuration by calling kikit with <code>--corrections PCBWAY_CORRECTION_CFG_1,PCBWAY_CORRECTION</code> or <code>--corrections PCBWAY_CORRECTION_CFG_2,PCBWAY_CORRECTION</code>.</p>"},{"location":"installation/choosing_kicad/","title":"Choosing KiCAD version","text":"<p>When you have multiple versions of KiCAD installed, it might be desirable to run KiKit with one or another (e.g., to not convert your designs into new format).</p> <p>KiKit loads the Python API directly via a module, so which module is loaded (which KiCAD version is used) follows standard Python conventions. Therefore, to choose a particular KiCAD version, just specify the environmental variable <code>PYTHONPATH</code>. The path have to point to a folder containing the module (<code>pcbnew.py</code> file).</p> <p>The most common on linux are:</p> <pre><code>stable: /usr/lib/python3/dist-packages/pcbn\nnightly: /usr/lib/kicad-nightly/lib/python3/dist-packages/\n</code></pre> <p>E.g., to run KiKit with nightly, run:</p> <pre><code>PYTHONPATH=/usr/lib/kicad-nightly/lib/python3/dist-packages/ kikit\n</code></pre> <p>To run KiKit with a KiCAD you compiled (and not installed):</p> <pre><code>PYTHONPATH=path-to-sources/build/pcbnew kikit\n</code></pre> <p>This also works when you invoke <code>make</code> as environmental variables are propagated:</p> <pre><code>PYTHONPATH=/usr/lib/kicad-nightly/lib/python3/dist-packages/ make\n</code></pre>"},{"location":"installation/docker/","title":"Running KiKit via Docker","text":"<p>This method is applicable to Windows, Linux and MacOS. It provides access to all of the CLI commands in a known-working container, but doesn't allow your local install of KiCad to access KiKit via the KiKit plugin.</p> <p>First, install Docker. The installation procedure varies by the platform, so Google up a recent guide for your platform.</p> <p>With Docker you can skip all of the install steps and instead run KiKit via (on Linux or Mac):</p> <p><pre><code>docker run -v $(pwd):/kikit yaqwsx/kikit --help\n</code></pre> (replacing the call to display the <code>--help</code> with whatever command you want to run.  Try <code>--version</code> or <code>panelize</code>)</p> <p>or on Windows: <pre><code>docker run -v %cd%:/kikit yaqwsx/kikit --help\n</code></pre></p> <p>Note that on Windows you might have to explicitly allow for mounting directories outside your user account (see the following topic).</p>"},{"location":"installation/docker/#creating-an-alias-to-kikit-in-docker-to-save-some-typing","title":"Creating an alias to KiKit in Docker to save some typing","text":"<p>If you're on Linux or Mac and are going to run commands repeatedly within the same directory you can create an alias within the current terminal session via: <pre><code>alias kikit=\"docker run -v $(pwd):/kikit yaqwsx/kikit\"\n</code></pre> Note that <code>alias</code> is a Linux/ Unix command so won't work on Windows, you'll need to call <code>docker run -v %cd%:/kikit yaqwsx/kikit</code> each time. Also note that you must update the alias (by running the same alias command again) if you move to a different directory.  The current working directory for the alias is \"frozen\" at the directory you create the alias in.</p> <p>From then on, until you close that terminal, you'll be able to just run <code>kikit</code> followed by the relevant paramenters (e.g. <code>kikit --version</code> or <code>kikit panelize</code>).</p>"},{"location":"installation/docker/#running-different-versions-of-kikit-via-docker","title":"Running different versions of KiKit via Docker","text":"<p>If you would like to run a particular version of KiKit, simply append a tag to the image name (e.g., <code>yaqwsx/kikit:nightly</code>), and Docker will pull that version down and run that for you instead:</p> <pre><code>docker run -v $(pwd):/kikit yaqwsx/kikit:nightly --version\n</code></pre> <p>We provide the following containers:</p> <ul> <li>latests: The latest stable version of KiKit with the newest stable KiCAD.</li> <li>vX.Y.Z-KiCADvA: A container with particular version of KiKit backed by   given version of KiCAD.</li> <li>nightly, nightly-m1: Daily build of KiKit from the upstream version   with the newest KiCAD. The m1 flavour supports mac M1.</li> </ul> <p>A full list is available on Dockerhub.</p>"},{"location":"installation/docker/#mac-m1-containers","title":"Mac M1 containers","text":"<p>There are also nightly containers of Mac M1 available with tag <code>nightly-m1</code>.</p> <p>If you want to use Makefile for your projects, the preferable way is to invoke <code>make</code> inside the container. The Docker image contains several often used tools and you can even run KiCAD from it (if you supply it with X-server).  To call <code>make</code> within the container, override the container's entrypoint:</p> <p><pre><code>docker run -it -v $(pwd):/kikit --entrypoint '/usr/bin/make' --help\n</code></pre> (replacing <code>--help</code> with your make command, such as <code>build</code> or <code>test</code>).</p>"},{"location":"installation/gui_and_libs/","title":"GUI and libs installation","text":""},{"location":"installation/gui_and_libs/#kikit-symbol-and-footprint-libraries","title":"KiKit Symbol and Footprint Libraries","text":"<p>From v6 onwards KiCad comes with a \"Plugin and Content Manager\" (PCM) which can be used to add the KiKit symbol and footprint libraries used in multi-board workflows.  The PCM is new functionality for KiCad though, and only does part of the installation in v6.  To install the libraries using the PCM:</p> <ol> <li>Open KiCad</li> <li>Open the <code>Tools</code> menu and select <code>Plugin and Content Manager</code></li> <li>Select the <code>Libraries</code> tab and scroll down to <code>KiKit Library</code></li> <li>Press <code>Install</code> and then <code>Apply Changes</code></li> <li>Close the Plugin and Content Manager</li> </ol> <p>The following steps are only required in KiCad 6, they are automated in KiCad 7:</p> <ol> <li>Back in the main KiCad window, open the <code>Preferences</code> menu and select <code>Manage Symbol Libraries</code></li> <li>Select the <code>Global Libraries</code> tab, and click the <code>+</code> icon towards the bottom of the window then enter <code>kikit</code> (all lowercase) as the nickname, and <code>${KICAD6_3RD_PARTY}/symbols/com_github_yaqwsx_kikit-library/kikit.kicad_sym</code> as the Library Path.</li> <li>Press <code>OK</code></li> <li>Back in the main KiCad window, open the <code>Preferences</code> menu and select <code>Manage Footprint Libraries</code></li> <li>As before, add a row to the table in the <code>Global Libraries</code> tab, with a nickname <code>kikit</code> (all lowercase again), and this time enter <code>${KICAD6_3RD_PARTY}/footprints/com_github_yaqwsx_kikit-library/kikit.pretty</code> for the Library Path.</li> <li>Press <code>OK</code></li> <li>From now on, you can find the KiKit symbols and footprints under <code>kikit</code> alongside all the others.</li> </ol>"},{"location":"installation/intro/","title":"Installation","text":"<p>KiKit consists of three parts:</p> <ul> <li>a backend (a Python library that does all the heavy work and provides CLI)</li> <li>KiCAD PCM plugin which adds GUI for KiCAD, and</li> <li>KiCAD symbol and footprint libraries.</li> </ul> <p>Unfortunately, it is not possible to install all three parts automatically in a single step due to technical limitations of KiCAD's PCM at the moment, so you have to install them separately.</p>"},{"location":"installation/intro/#backend-installation","title":"Backend installation","text":"<p>The backend installation differs slightly based on the platform:</p> <ul> <li>Linux guide</li> <li>Windows guide</li> <li>macOS guide</li> </ul>"},{"location":"installation/intro/#gui-and-libraries-installation","title":"GUI and libraries installation","text":"<p>GUI plugins and libraries are available via KiCAD PCM. See details about their installation.</p>"},{"location":"installation/intro/#optional-dependencies","title":"Optional dependencies","text":"<p>Some KiKit features rely on external dependencies:</p> <ul> <li>PcbDraw \u2013 to be able to export   presentation pages</li> <li>OpenSCAD \u2013 to be able to export 3D models of stencil.   Install it via your system package manage.</li> </ul>"},{"location":"installation/intro/#running-kikit-in-ci-or-isolated-environment-via-docker","title":"Running KiKit in CI or isolated environment via Docker","text":"<p>We also distribute a Docker container for running KiKit in CI or on platform where it is hard to meet all dependencies. This mode doesn't support GUI. Learn more about the docker images.</p>"},{"location":"installation/linux/","title":"Installation on Linux","text":"<p>KiKit is distributed as PyPi package.</p>"},{"location":"installation/linux/#instalation-for-kicad-installed-via-system-package-manager","title":"Instalation for KiCAD installed via system package manager","text":"<p>The installation consists of a single command you have to enter into the terminal. If you installed KiCAD via package manager (apt, yum, etc.) you can use a regular terminal and enter <code>pip3 install kikit</code>. Now you are ready to use KiKit.</p>"},{"location":"installation/linux/#installation-for-flatpak-kicad","title":"Installation for Flatpak KiCAD","text":"<p>However, if you installed KiCAD via Flatpak, you have to open a special terminal as Flatpak sandboxes the applications. Open terminal and invoke <code>flatpak run --command=sh org.kicad.KiCad</code>, this will open a terminal session inside the KiCAD\u2019s sandbox. Now you can install pip via <code>python3 -m ensurepip</code> and then, inside the same terminal you can install KiKit: <code>python3 -m pip install kikit</code>. If you would like to use CLI interface, all commands have to be invoked inside the shell <code>flatpak run --command=sh org.kicad.KiCad</code>, and, instead of <code>kikit something</code> you have to use <code>python -m kikit.ui something</code>.</p>"},{"location":"installation/linux/#testing-the-installation","title":"Testing the installation","text":"<p>Now you can test that it works:</p> <pre><code>&gt; kikit --help\n</code></pre> <p>You should get something like this:</p> <pre><code>Usage: kikit [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  drc       Validate design rules of the board\n  export    Export KiCAD boards\n  fab       Export complete manufacturing data for given fabrication houses\n  modify    Modify board items\n  panelize  Panelize boards\n  present   Prepare board presentation\n  separate  Separate a single board out of a multi-board design.\n  stencil   Create solder paste stencils\n</code></pre> <p>Now you are done with the basic installation. If you plan to use graphical interface, install GUI frontend and libraries via PCM.</p>"},{"location":"installation/macos/","title":"KiKit Installation on MacOS","text":"<p>Installation on MacOS is a little more involved as MacOS enforces that all external programs are signed. KiCAD installed via homebrew is signed, however, once plugins with binary dependencies are installed, the signature gets invalidated. This prevents KiKit from running.</p> <p>The current solution is to re-sign KiCAD after KiKit installation. Therefore, KiKit's installation on MacOS is twofold: - create a self-signed certificate - install KiKit and sign KiCAD</p>"},{"location":"installation/macos/#create-a-codesigning-certificate","title":"Create a codesigning certificate","text":"<p>Open Keychain a select \"Create a Certificate\":</p> <p></p> <p>Then, enter name \"kikit\", select \"Self-Signed Root\" and type \"Code Signing\":</p> <p></p> <p>Confirm and the certificate is ready.</p>"},{"location":"installation/macos/#install-kikit-related-wrappers","title":"Install KiKit &amp; related wrappers","text":"<p>We provide a script for KiKit installation's, KiCAD signing and creating a wrapper script for KiKit. You can find the script here. You can download and run it. Open a terminal and enter:</p> <pre><code>$ curl -O https://raw.githubusercontent.com/yaqwsx/KiKit/master/scripts/installMacOS.bash\n$ sudo bash installMacOS.bash\n</code></pre> <p>The script will ask you for a password several times. Once it finishes, you can test it:</p> <pre><code>$ kikit --help\nUsage: python3 -m kikit.ui [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  drc       Validate design rules of the board\n  export    Export KiCAD boards\n  fab       Export complete manufacturing data for given fabrication houses\n  modify    Modify board items\n  panelize  Panelize boards\n  present   Prepare board presentation\n  separate  Separate a single board out of a multi-board design.\n  stencil   Create solder paste stencils\n</code></pre> <p>Once you install the PCM plugin, KiKit will be available via GUI in Pcbnew.</p>"},{"location":"installation/upgrading/","title":"Upgrading KiKit and installing special versions","text":""},{"location":"installation/upgrading/#upgrading-kikit","title":"Upgrading KiKit","text":"<p>If you want to upgrade KiKit, you have to perform two steps:</p> <ul> <li>you upgrade the backend by running <code>pip install -U kikit</code> in the command line   (depending on the platform, see the installation instructions for individual   platform).</li> <li>then you can upgrade the PCM packages within KiCAD. Note that this step is   often not needed. If it will be needed, the release notes will say so.</li> </ul>"},{"location":"installation/upgrading/#installing-a-special-version-of-kikit","title":"Installing a special version of KiKit","text":"<p>If you would like to install a specific version of KiKit (e.g., the upstream version), you can install it directly from git. The command for that is:</p> <pre><code># The master branch (also called the upstream version) - the most up-to-date KiKit there is (but might me unstable)\npip install https://github.com/yaqwsx/KiKit/archive/master.zip\n# A concrete branch, e.g., from a pull request\npip3 install https://github.com/yaqwsx/KiKit/archive/someBranchName.zip\n</code></pre>"},{"location":"installation/windows/","title":"Windows","text":""},{"location":"installation/windows/#installation-on-windows","title":"Installation on Windows","text":"<p>To install KiKit on Windows, you have to open \"KiCAD Command Prompt\". You can find it in the start menu:</p> <p></p> <p>Once you have it open like this:</p> <p></p> <p>you can put command in there and confirm them by pressing enter. This is also the prompt from which you will invoke all KiKit's CLI commands. They, unfortunately, does not work in an ordinary Command prompt due to the way KiCAD is packaged on Windows.</p> <p>Then you have to enter the following command to install it:</p> <pre><code>pip install kikit\n</code></pre> <p>Now you can test that it works:</p> <pre><code>kikit --help\n</code></pre> <p>You should get something like this:</p> <pre><code>Usage: kikit [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  drc       Validate design rules of the board\n  export    Export KiCAD boards\n  fab       Export complete manufacturing data for given fabrication houses\n  modify    Modify board items\n  panelize  Panelize boards\n  present   Prepare board presentation\n  separate  Separate a single board out of a multi-board design.\n  stencil   Create solder paste stencils\n</code></pre> <p>Now you are done with the basic installation. Don't forget to get the GUI frontend and libraries via PCM.</p>"},{"location":"panelization/cli/","title":"Panelization CLI","text":"<p>The whole panelization process of KiKit's CLI is driven by a configuration structure. The configuration contains several categories (e.g., <code>layout</code>, <code>tabs</code>, <code>framing</code>). Each of the categories have number of named parameters (e.g., <code>tabsCount</code>). All categories and their parameters are described further below.</p> <p>Note that you can use the pcbnew action plugin to interactively construct the panelization configuration structure.</p>"},{"location":"panelization/cli/#configurations","title":"Configurations","text":"<p>The configuration can be supplied to KiKit via a JSON file with comments and from the command line. The example of a configuration in a JSON file is the following</p> <pre><code>{\n    // There can be C-like comments\n    \"layout\": {\n        \"type\": \"grid\",\n        \"rows\": 1,\n        \"cols\": 1,\n        \"hspace\": \"0mm\",\n        \"vspace\": \"0mm\",\n        \"rotation\": \"0deg\",\n        \"alternation\": \"none\",\n        \"renamenet\": \"Board_{n}-{orig}\",\n        \"renameref\": \"{orig}\"\n    },\n    \"source\": {\n        \"type\": \"auto\",\n        \"tolerance\": \"1mm\"\n    },\n    \"tabs\": {\n        \"type\": \"normal\",\n        \"source\": \"none\"\n    },\n    \"cuts\": {\n        \"type\": \"none\"\n    },\n    \"framing\": {\n        \"type\": \"none\",\n        \"thickness\": \"0mm\",\n    },\n    \"post\": {\n        \"type\": \"auto\",\n        \"millradius\": \"0mm\",\n        \"copperfill\": false\n    }\n}\n</code></pre> <p>KiKit accepts <code>-p &lt;configurationFile&gt;</code> option to specify one or more configurations. When multiple configurations are specified, they are composed into a single configuration. The later specified configurations overwrite parameters of the former specified configurations. This allows us to start with a basic configuration and have a number of small configurations specifying details.</p> <p>To give and example, consider the two following configurations:</p> <pre><code>// A\n{\n    \"tabs\": {\n        \"type\": \"normal\",\n        \"width\": \"3mm\"\n    },\n    \"framing\": {\n        \"type\": \"frame\"\n    }\n}\n\n// B\n{\n    \"framing\": {\n        \"type\": \"rails\"\n        \"width\": \"5mm\"\n    }\n}\n</code></pre> <p>When we merge <code>B</code> into <code>A</code>, we get:</p> <pre><code>{\n    \"tabs\": {\n        \"type\": \"normal\",\n        \"width\": \"3mm\"\n    },\n    \"framing\": {\n        \"type\": \"rails\"\n        \"width\": \"5mm\"\n    }\n}\n</code></pre> <p>You can also override every parameter from CLI. There is an option for each category, which accepts a semicolon-separated list of key-value pairs; e.g.:</p> <pre><code>--layout 'rows: 3; cols: 4'\n</code></pre> <p>The options from CLI have the highest priority - they override values from specified from the files. If you need to specify the character <code>;</code>, you can escape it via <code>\\</code>.</p> <p>Therefore, a full invocation of KiKit for panelization can look like this: <pre><code>kikit panelize -p myDefault.json -p useVcuts.json -p myFrame.json\n    --layout 'rows: 3; cols: 4'\n    board.kicad_pcb panel.kicad_pcb.\n</code></pre></p> <p>Note the single quotes -- without them your shell will eat the spaces and the command will be interpreted badly. The command will use our default configuration, then it will override some options to use V-cuts and then it adds a frame specified by <code>myFrame.json</code>. Last we specify the panel size from CLI.</p> <p>Note that KiKit always start with a default configuration (specified in the file default.json). There are also some configuration files shipped with KiKit. You can find them in the directory <code>kikit/resources/panelizePresets</code>. When you want to use them via option <code>-p</code>, just prefix their name with <code>:</code> and drop the suffix. E.g., for <code>vcuts.json</code> use <code>-p :vcuts</code>.</p> <p>If you would like to inspect which configuration was used by KiKit, you can dump it into a file with the <code>-d &lt;filename&gt;</code> option.</p>"},{"location":"panelization/cli/#units","title":"Units","text":"<p>You can specify units in the configuration files and CLI. Always specify them as string, e.g., \"2mm\" or \"0.5 inch\" (do not forget the quotes in the JSON files).</p> <p>Supported length units: mm, cm, dm, m, mil, inch, in.</p> <p>Supported angle units: deg, \u00b0, rad.</p>"},{"location":"panelization/cli/#configuration-categories","title":"Configuration categories","text":"<p>There are the following categories: layout, source, tabs, cuts, framing, and tooling.</p> <p>Each category has a mandatory parameter <code>type</code> which dictates the style of that feature. Note that you can specify the type parameter in a simplified manner in the CLI by specifying it first and omitting the <code>type</code> word; e.g., <code>--cuts 'mousebites, someParameter: 10cm'</code>.</p>"},{"location":"panelization/cli/#layout","title":"Layout","text":"<p>Types: grid, plugin</p> <p>Common options:</p> <ul> <li><code>hspace</code>, <code>vspace</code>, <code>space</code>: Specify the gap between the boards. You can   specify separately vertical and horizontal spacing or you can specify <code>space</code>   to make them the same (it has higher priority).</li> <li><code>rotation</code>: Rotate the boards before placing them in the panel</li> <li><code>renamenet</code>, <code>renameref</code>: A pattern by which to rename the nets and   references. You can use <code>{n}</code> and <code>{orig}</code> to get the board number and   original name. Default values are <code>Board_{n}-{orig}</code> for nets and <code>{orig}</code> for   references.</li> <li><code>baketext</code>: A flag that indicates if text variables should be substituted or   not.</li> </ul>"},{"location":"panelization/cli/#grid","title":"Grid","text":"<p>The boars are placed in a grid pattern connected by tabs. There are no special options.</p> <ul> <li><code>rows</code>, <code>cols</code>: Specify the number of boards in the grid pattern</li> <li><code>alternation</code>: Specify alternations of board rotation.<ul> <li><code>none</code>: Do not alternate</li> <li><code>rows</code>: Rotate boards by 180\u00b0 on every next row</li> <li><code>cols</code>: Rotate boards by 180\u00b0 on every next column</li> <li><code>rowsCols</code>: Rotate boards by 180\u00b0 based on a chessboard pattern</li> </ul> </li> <li><code>vbackbone</code>, <code>hbackbone</code>: The width of vertical and horizontal backbone (0   means no backbone). The backbone does not increase the spacing of the boards.</li> <li><code>vboneskip</code>, <code>hboneskip</code>: Skip every n backbones. I.e., 1 means place only   every other backbone.</li> <li><code>vbonefirst</code>, <code>hbonefirst</code>: Specify first backbone to render. Allows to   specify the offset when skipping backbones. The offset is indexed from 1.</li> <li><code>vbonecut</code>, <code>hbonecut</code>: true/false. If there are both backbones specified,   specifies if there should be a vertical or horizontal cut (or both) where the   backbones cross.</li> </ul>"},{"location":"panelization/cli/#plugin","title":"Plugin","text":"<p>Implements a custom layout based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#source","title":"Source","text":"<p>This option allows you to specify the source area, e.g., when multiple boards are present. You can read more about multi-board project here.</p> <p>Types: auto, rectangle, annotation</p> <p>Common options:</p> <ul> <li><code>stack</code>: specify the number of layers of the panel. Valid options are   <code>2layer</code>, <code>4layer</code>, <code>6layer</code> or <code>inehrit</code> (default). The use case for this   option is when you design a multiple boards in a single design and you   separate them, however, one boards is e.g., 4 layer and one 2 layer. Then you   design both of them as 4 layer and you specify <code>stack: 2layer</code> for the 2 layer   one when panelizing or separating.</li> </ul>"},{"location":"panelization/cli/#auto","title":"Auto","text":"<p>Find all board edges and use them to construct source rectangle. Suitable for most cases when there is only a single board in the design. Note that might want to increase <code>tolerance</code> or specify the source area explicitly via <code>rectangle</code> if you have components sticking out of your design.</p> <ul> <li><code>tolerance</code>: KiKit extracts only board items that fit fully into the source   area (including all drawings on all layers). Tolerance enlarges the source   area by given amount, to e.g., not omit KiKit annotations for tabs or   connectors sticking out of the board.</li> </ul>"},{"location":"panelization/cli/#rectangle","title":"Rectangle","text":"<p>Specify the source rectangle explicitly.</p> <ul> <li><code>tlx, tly, brx, bry</code>: specify the coordinates (via length units) of the   rectangle via top-left and bottom-right corner.</li> </ul>"},{"location":"panelization/cli/#annotation","title":"Annotation","text":"<p>KiKit offers you to place an annotation footprint <code>kikit:Board</code> into your design file to name the board. The area is determined by a bounding box of the lines in the <code>Edge.Cuts</code> layer that the arrows point to. Note that the tip of the arrow must lie on the PCB edge or slightly outside of it.</p> <ul> <li><code>ref</code>: specify the annotation symbol reference</li> <li><code>tolerance</code>: see above</li> </ul>"},{"location":"panelization/cli/#tabs","title":"Tabs","text":"<p>Types: fixed, spacing, full, annotation, plugin</p> <p>Place tabs. To make some of the options clear, please see the explanation of tab placement process.</p>"},{"location":"panelization/cli/#fixed","title":"Fixed","text":"<p>Place given number of tabs on the PCB edge. The tabs are spaced uniformly. If you need a custom tab placement (e.g., to avoid critical feature), see type annotation.</p> <ul> <li><code>vwidth</code>, <code>hwidth</code>, <code>width</code>: The width of tabs in the vertical and horizontal   direction. <code>width</code> overrides both.</li> <li><code>vcount</code>, <code>hcount</code>: Number of tabs in a given direction.</li> <li><code>mindistance</code>: Minimal spacing between the tabs. If there are too many tabs,   their count is reduced.</li> </ul>"},{"location":"panelization/cli/#spacing","title":"Spacing","text":"<p>Place tabs on the PCB edges based on spacing.</p> <ul> <li><code>vwidth</code>, <code>hwidth</code>, <code>width</code>: The width of tabs in the vertical and horizontal   direction. <code>width</code> overrides both.</li> <li><code>spacing</code>: The maximum spacing of the tabs.</li> </ul>"},{"location":"panelization/cli/#full","title":"Full","text":"<p>Create tabs that are full width of the PCB. Suitable for PCBs separated by V-Cuts. This mode does not make much sense for mousebites in practice. Note that in this mode the cuts do not faithfully copy the PCB outline and, instead, they cut the bounding box of the PCB. There are no other options.</p> <ul> <li><code>cutout</code>: When your design features open pockets on the side, this parameter   specifies extra cutout depth in order to ensure that a sharp corner of the   pocket can be milled. The default is 1\u00a0mm.</li> <li><code>patchcorners</code>: The full tabs are appended to the nearest flat face of the   PCB. If the PCB has sharp corners, you want to add patches of substrate to   these corners. However, if the PCB has fillet or miter, you don't want to   apply the patches.</li> </ul>"},{"location":"panelization/cli/#corner","title":"Corner","text":"<p>Create tabs in the corners of the PCB.</p> <ul> <li><code>width</code>: The width of tabs</li> </ul>"},{"location":"panelization/cli/#annotation_1","title":"Annotation","text":"<p>Add tabs based on PCB annotations. Place a footprint <code>kikit:Tab</code> at the edges of your PCB. You can edit the text field prefixed with <code>KIKIT:</code> to adjust the tab parameters. If you want to specify a custom tab symbol (e.g., with predefined) width, you can specify <code>tabfootprints</code> as a list of footprints separated by comma. For example: <code>myLib:Tab2mm, myLib:Tab3mm</code>.</p> <p>The individual tabs can have the following properties specified in the text field of the component as <code>KIKIT:&lt;propertyname&gt;</code>:</p> <ul> <li><code>width</code>: width of the tab.</li> </ul>"},{"location":"panelization/cli/#plugin_1","title":"Plugin","text":"<p>Tabs based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#cuts","title":"Cuts","text":"<p>Specify how to perform the cuts on the tabs separating the board.</p> <p>Types: none, mousebites, vcuts, layer, plugin</p>"},{"location":"panelization/cli/#none","title":"None","text":"<p>Do not perform any cuts</p>"},{"location":"panelization/cli/#mousebites","title":"Mousebites","text":"<p>Use mousebites to</p> <ul> <li><code>drill</code> - specify drill size for the bites</li> <li><code>spacing</code> - specify the spacing of the holes</li> <li><code>offset</code> - specify the offset, positive offset puts the cuts into the board,   negative puts the cuts into the tabs</li> <li><code>prolong</code> - distance for tangential prolongation of the cuts (to cut through   the internal corner fillets caused by milling)</li> </ul>"},{"location":"panelization/cli/#v-cuts","title":"V-Cuts","text":"<ul> <li><code>clearance</code> - specify clearance for copper around V-cuts</li> <li><code>cutcurves</code> - true/false - specify if curves should be approximated by   straight cuts (e.g., for cutting tabs on circular boards)</li> <li><code>offset</code> - specify the offset, positive offset puts the cuts into the board,   negative puts the cuts into the tabs</li> <li><code>layer</code> - specify the layer to render V-cuts on.</li> <li><code>linewidth</code> - specify linewidth</li> <li><code>endprolongation</code> - prolongation of the cut line from the board line on the   side without text.</li> <li><code>textprolongation</code> - the same as above, just on the text side</li> <li><code>textoffset</code> - offset of the text from the cut line</li> <li><code>template</code> - a string template for text to render. Can contain variables   listed below, e.g., <code>V-CUT {pos_mm}</code>.<ul> <li><code>pos_mm</code>, <code>pos_inch</code> \u2013 position of the V-cut from the panel origin</li> <li><code>pos_inv_mm</code>, <code>pos_inv_inch</code> \u2013 inverted position of the V-cut from the panel origin</li> </ul> </li> </ul>"},{"location":"panelization/cli/#layer","title":"Layer","text":"<p>When KiKit reports it cannot perform cuts, you can render the cuts into a layer with this option to understand what's going on. Shouldn't be used for the final design.</p> <ul> <li><code>layer</code> - specify the layer to render the cuts on.</li> <li><code>prolong</code> - distance for tangential prolongation of the cuts. It has the same   meaning as mousebites.</li> <li><code>linewidth</code> - width of line to render</li> </ul>"},{"location":"panelization/cli/#plugin_2","title":"Plugin","text":"<p>Cuts based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#framing","title":"Framing","text":"<p>KiKit allows you to frame the panel with a full frame, or bottom/top or left/right rails.</p> <p>Types: none, railstb, railslr, frame, tightframe, plugin Common options:</p> <ul> <li><code>hspace</code>, <code>vspace</code>, <code>space</code> - specify the space between PCB and the   frame/rail. <code>space</code> overrides <code>hspace and vspace</code>.</li> <li><code>width</code> - specify with of the rails or frame</li> <li><code>fillet</code>, <code>chamfer</code> - fillet/chamfer frame corners. Specify radius or chamfer   size. You can also separately specify <code>chamferwidth</code> and <code>chamferheight</code> to   create a non 45\u00b0 chamfer.</li> <li><code>mintotalheight</code>, <code>mintotalwidth</code> \u2013 if needed, add extra material to the rail   or frame to meet the minimal requested size. Useful for services that require   minimal panel size.</li> </ul>"},{"location":"panelization/cli/#railstbrailslr","title":"Railstb/Railslr","text":"<p>Add rail (either on top and bottom or on left and right) to the panel.</p>"},{"location":"panelization/cli/#frame","title":"Frame","text":"<p>Add a frame around the board.</p> <ul> <li><code>cuts</code> - one of <code>none</code>, <code>both</code>, <code>v</code>, <code>h</code> - specify whether to add cuts to the   corners of the frame for easy removal. Default <code>both</code>.</li> </ul>"},{"location":"panelization/cli/#tightframe","title":"Tightframe","text":"<p>Add a frame around the board which fills the whole area of the panel - the boards have just a milled slot around their perimeter.</p> <ul> <li><code>slotwidth</code> - width of the milled slot.</li> </ul>"},{"location":"panelization/cli/#plugin_3","title":"Plugin","text":"<p>Frame based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#tooling","title":"Tooling","text":"<p>Add tooling holes to the (rail/frame of) the panel. The holes are positioned by</p> <p>Types: none, 3hole, 4hole, plugin</p> <p>Common options:</p> <ul> <li><code>hoffset</code>, <code>voffset</code> - specify the offset from from panel edges</li> <li><code>size</code> - diameter of the holes</li> <li><code>paste</code> - if true, the holes are included in the paste layer (therefore they   appear on the stencil).</li> <li><code>solderMaskMargin</code> - diameter of solder mask (optional)</li> </ul>"},{"location":"panelization/cli/#plugin_4","title":"Plugin","text":"<p>Tooling based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#fiducials","title":"Fiducials","text":"<p>Add fiducial to the (rail/frame of) the panel.</p> <p>Types: none, 3fid, 4fid, plugin</p> <p>Common options:</p> <ul> <li><code>hoffset</code>, <code>voffset</code> - specify the offset from from panel edges</li> <li><code>coppersize</code>, <code>opening</code> - diameter of the copper spot and solder mask opening</li> <li><code>paste</code> - if true, the fiducials are included in the paste layer (therefore they   appear on the stencil).</li> </ul>"},{"location":"panelization/cli/#plugin_5","title":"Plugin","text":"<p>Fiducials based on a plugin.</p> <ul> <li><code>code</code>: the plugin specification. See (plugin documentation)[plugin.md] for   more details</li> <li><code>arg</code>: text argument for the user plugin</li> </ul>"},{"location":"panelization/cli/#text","title":"Text","text":"<p>Add text to the panel. Allows you to put a single block of text on panel. You can use variables enclosed in <code>{}</code>. E.g. <code>{boardTitle} | {boardDate}</code>. The list of all available variables in listed bellow. You can also use the variables specified in the project. They are prefixed with <code>user-</code>. That is, to include your variable <code>revision</code> in KiKit text, use formatting string <code>Rev: {user-revision}</code>. In the case you need more independent texts on the panel, you can use sections names <code>text2</code>, <code>text3</code> and <code>text3</code> to add at most 4 text. All these sections behave the same and accept the same options.</p> <p>If you need more texts or more sophisticated placing options, see <code>script</code> option from <code>postprocess</code>.</p> <p>Types: none, simple</p> <p>Common options:</p> <ul> <li><code>text</code> - The text to be displayed. Note that you can escape <code>;</code> via <code>\\</code></li> <li><code>anchor</code> - Origin of the text. Can be one of <code>tl</code>, <code>tr</code>, <code>bl</code>, <code>br</code> (corners),   <code>mt</code>, <code>mb</code>, <code>ml</code>, <code>mr</code> (middle of sides), <code>c</code> (center). The anchors refer to   the panel outline. Default <code>mt</code></li> <li><code>hoffset</code>, <code>voffset</code> - specify the offset from anchor. Respects KiCAD   coordinate system. Default <code>0mm</code>.</li> <li><code>orientation</code> - specify the orientation (angle). Default <code>0deg</code></li> <li><code>width</code>, <code>height</code> - width and height of the characters (the same parameters as   KiCAD uses). Default <code>1.5mm</code>.</li> <li><code>hjustify</code> - justification of the text. One of <code>left</code>, <code>right</code>, <code>center</code>.   Default <code>center</code>.</li> <li><code>vjustify</code> - justification of the text. One of <code>top</code>, <code>bottom</code>, <code>center</code>.   Default <code>center</code></li> <li><code>thickness</code> - stroke thickness. Default <code>0.3mm</code>.</li> <li><code>layer</code> - specify text layer</li> <li><code>plugin</code> - specify the plugin that provides extra variables for the text</li> </ul>"},{"location":"panelization/cli/#available-variables-in-text","title":"Available variables in text","text":"<ul> <li><code>date</code> - formats current date as <code>&lt;year&gt;-&lt;month&gt;-&lt;day&gt;</code></li> <li><code>time24</code> - formats current time in 24-hour format</li> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> - individual variables   for any date format</li> <li><code>boardTitle</code> - the title from the source board</li> <li><code>boardDate</code> - the date from the source board</li> <li><code>boardRevision</code> - the revision from the source board</li> <li><code>boardCompany</code> - the company from the source board</li> <li><code>boardComment1</code>-<code>boardComment9</code> - comments from the source board</li> </ul> <p>You can get extra variables by providing custom text plugin via the <code>plugin</code> field.</p>"},{"location":"panelization/cli/#page","title":"Page","text":"<p>Sets page size on the resulting panel and position the panel in the page. The type of style dictates paper size. The default <code>inherit</code> option inherits paper size from the source board. This feature is not supported on KiCAD 5.</p> <p>Types: <code>inherit</code>, <code>custom</code>, <code>A0</code>, <code>A1</code>, <code>A2</code>, <code>A3</code>, <code>A4</code>, <code>A5</code>, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>USLetter</code>, <code>USLegal</code>, <code>USLedger</code>, <code>A0-portrait</code>, <code>A1-portrait</code>, <code>A2-portrait</code>, <code>A3-portrait</code>, <code>A4-portrait</code>, <code>A5-portrait</code>, <code>A-portrait</code>, <code>B-portrait</code>, <code>C-portrait</code>, <code>D-portrait</code>, <code>E-portrait</code>, <code>USLetter-portrait</code>, <code>USLegal-portrait</code>, <code>USLedger-portrait</code></p> <p>Common options:</p> <ul> <li><code>anchor</code> - Point of the panel to be placed at given position. Can be one of   <code>tl</code>, <code>tr</code>, <code>bl</code>, <code>br</code> (corners), <code>mt</code>, <code>mb</code>, <code>ml</code>, <code>mr</code> (middle of sides),   <code>c</code> (center). The anchors refer to the panel outline. Default <code>mt</code></li> <li><code>posx</code>, <code>posy</code> - the position of the panel on the page. Default <code>50%</code> for   <code>posx</code> and <code>20mm</code> for <code>posy</code>.</li> </ul>"},{"location":"panelization/cli/#custom","title":"Custom","text":"<p>Instead of the pre-defined paper size you can also specify a custom paper size via <code>width</code> and <code>height</code>.</p>"},{"location":"panelization/cli/#copperfill","title":"Copperfill","text":"<p>Fill non-board areas of the panel with copper.</p> <p>Types: none, solid, hatched, hex</p> <p>Common options:</p> <ul> <li><code>clearance</code> - optional extra clearance from the board perimeters. Suitable   for, e.g., not filling the tabs with copper.</li> <li><code>edgeclearance</code> - specifies clearance between the fill and panel perimeter.</li> <li><code>layers</code> - comma-separated list of layer to fill. Default top and bottom. You   can specify a shortcut <code>all</code> to fill all layers.</li> </ul>"},{"location":"panelization/cli/#solid","title":"Solid","text":"<p>Fill with solid copper.</p>"},{"location":"panelization/cli/#hatched","title":"Hatched","text":"<p>Use hatch pattern for the fill.</p> <ul> <li><code>width</code> - the width of the strokes</li> <li><code>spacing</code> - the space between the strokes</li> <li><code>orientation</code> - the orientation of the strokes</li> </ul>"},{"location":"panelization/cli/#hex","title":"Hex","text":"<p>Use hexagon pattern for the fill.</p> <ul> <li><code>diameter</code> \u2013 diameter of the hexagons</li> <li><code>spacing</code> \u2013 space between the hexagons</li> <li><code>threshold</code> \u2013 a percentage value that will discard fragments smaller than   given threshold</li> </ul>"},{"location":"panelization/cli/#post","title":"Post","text":"<p>Finishing touches to the panel.</p> <p>Types: auto</p> <p>Common options:</p> <ul> <li><code>copperfill</code> - fill tabs and frame with copper (e.g., to save etchant or to   increase rigidity of flex-PCB panels)</li> <li><code>millradius</code> - simulate the milling operation (add fillets to the internal   corners). Specify mill radius (usually 1 mm). 0 radius disables the   functionality.</li> <li><code>millradiusouter</code> \u00ad\u2013 same as the previous one, modifies only board outer   counter. No internal features of the board are affected.</li> <li><code>reconstructarcs</code> - the panelization process works on top of a polygonal   representation of the board. This options allows to reconstruct the arcs in   the design before saving the panel.</li> <li><code>refillzones</code> \u2013 refill the user zones after the panel is build. This is only   necessary when you want your zones to avoid cuts in panel.</li> <li><code>script</code> - a path to custom Python file. The file should contain a function   <code>kikitPostprocess(panel, args)</code> that receives the prepared panel as the   <code>kikit.panelize.Panel</code> object and the user-supplied arguments as a string -   see <code>scriptarg</code>. The function can make arbitrary changes to the panel - you   can append text, footprints, alter labels, etc. The function is invoked after   the whole panel is constructed (including all other postprocessing). If you   try to add a functionality for a common fabrication houses via scripting,   consider submitting PR for KiKit.</li> <li><code>scriptarg</code>: An arbitrary string passed to the user post-processing script   specified in <code>script</code></li> <li><code>origin</code> - specify if the auxilary origin an grid origin should be placed. Can   be one of <code>tl</code>, <code>tr</code>, <code>bl</code>, <code>br</code> (corners), <code>mt</code>, <code>mb</code>, <code>ml</code>, <code>mr</code> (middle of   sides), <code>c</code> (center). Empty string does not changes the origin.</li> <li><code>dimensions</code> - <code>true</code> or <code>false</code>. Draw dimensions with the panel size.</li> <li><code>edgewidth</code> \u00ad\u2013 width of the line for panel edges (that is the lines in the   <code>Edge.Cuts</code> layer).</li> </ul>"},{"location":"panelization/examples/","title":"Examples","text":"<p>This document will show you several examples of KiKit CLI for panelization. Note that this is not an exhaustive description of everything that KiKit can do, nor proper documentation. For further details, please refer to:</p> <ul> <li>description of all panelization options</li> <li>more detail about KiKit's algorithm for tab creation</li> <li>reference for the Python interface</li> </ul> <p>We will show everything on a single board located in <code>docs/resources/conn.kicad_pcb</code>. The board looks like this when rendered via PcbDraw:</p> <p></p>"},{"location":"panelization/examples/#basic-panels-layout","title":"Basic panels &amp; layout","text":"<p>Let's start with our first panel.</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2;' \\\n    --tabs full \\\n    --cuts vcuts \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2;\" ^\n    --tabs full ^\n    --cuts vcuts ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>We specified that we want 2x2 panel, no space between board and separate them by V-cuts. We also specified that we want to build full tabs (although no tabs are visible in this example). This is ,however, essential \u2013 if we omitted tabs, no cuts between the boards would be performed. Note, that due to the rounded corners, this panel cannot be manufactured. We will fix it later.</p> <p>Note that the <code>\\</code> in the input is there to make shell happy, so we can break our command into multiple lines. Also note that there are single quotes around the key-value pair \u2013 again, to make shell happy and to interpret a string with spaces as a single option.</p> <p>Note that on Windows you have the enter the commands into KiCAD Command Prompt instead of the regular Command Prompt. You can find it under the Start menu.</p> <p>Also note that KiKit accepts all options in categories (e.g., <code>layout</code>, <code>tabs</code>, <code>cuts</code>, ...). You can specify the parameters as a semicolon-separated key-value list. To learn about the precise syntax of the CLI and about all options, please refer to \u2013 documentation.</p> <p>One side note \u2013 if you try it with your own board some components might be gone. KiKit respects the KiCAD component selection criteria. When you specify an input rectangle, only the components that fully fit inside the input rectangle are selected. This however take in account both name and value labels (even when they are hidden).</p> <p>When you do not specify the source are explicitly, KiKit takes the board outline bounding box as the source area. Therefore, by default, components outside the board substrate are not copied to panel.</p> <p>Note that this is intended behavior; for once it is consistent with KiCAD behavior of user selection and also it allows to easily ignore surrounding comments and drawings in the board sheet (it makes no sense to have 12 same copies of the notes around the board).</p> <p>How to include the missing components? - specify the source area explicitly to include all your components - specify <code>--source 'tolerance: 10mm'</code> to enlarge the board outline bounding box   by e.g. 10 mm. The default value is 1 mm.</p> <p>I told you that the panel above is not suitable for manufacturing. Let's see why:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2;' \\\n    --tabs full \\\n    --cuts vcuts \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2;\" ^\n    --tabs full ^\n    --cuts vcuts ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>We specified a milling simulation post-processing. This simulates the milling operation in the fab house. As you can see, the sharp internal corners cannot be manufactured. I recommend you to use milling postprocessing always \u2013 you can easily see if your cuts are off or you have too narrow slots in your design.</p> <p>Usually, one would use full tabs only for rectangular boards. Usually, when you have rounded corners, you will use short tabs instead and add some space between the boards. So let's fix it:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; hwidth: 10mm; vwidth: 15mm' \\\n    --cuts vcuts \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; hwidth: 10mm; vwidth: 15mm\" ^\n    --cuts vcuts ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>In that way, the rounded corners can be machined. Lets' see the same example with mousebites instead:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 5mm' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 5mm\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>We changed cut type to mousebites and we specified that they should be performed by 0.5mm holes with a spacing of 1 mm. You could also use inches if you want \u2013 just specify `in. Since we use mousebites, we used narrower tabs. We also specified that the cuts should be inset 0.25 mm into the board outline. This is suitable when your board should fit into a cover \u2013 when you break away the tabs, all burs will be inside the intended board outline. <p>What happens, when we simulate the milling operation?</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 5mm' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 5mm\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>See? The cuts are somewhat short. This is due to the internal corners that cannot be milled. KiKit can fix that for you \u2013 just specify you want to prolong your cuts tangentially by a small amount:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>If you want, you can also specify a number of tabs to generate. KiKit will place them evenly:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>You can also append frame or rails to the panel. Frames and rail are useful in the following situations:</p> <ul> <li>you want to assemble your board, so you need tooling holes, fiducial.</li> <li>you want to append a text to board (e.g., to identify a manufacturing batch)</li> <li>your boards are not rectangluar and you want to use V-Cuts (most manufactures   require the outer edge of the panel to be a rectangle in order to manufacture   V-Cuts)</li> </ul> <p>Let's start with rails:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Similarly, you can add left and right rail via the <code>railslr</code> type. If you want a full frame, use the type <code>frame</code>. When you place a full frame, it might make sense to include cuts in the corner of the frame, so you can break it apart easily. Let's see an example:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'frame; width: 5mm; space: 3mm; cuts: both' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"frame; width: 5mm; space: 3mm; cuts: both\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Note that you can also use just only a vertical or horizontal frame cuts:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'frame; width: 5mm; space: 3mm; cuts: h' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"frame; width: 5mm; space: 3mm; cuts: h\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>When you use V-cuts it might make sense to not remove all material, but only mill a slot around the board of the board. This yields a stronger panel \u2013 and some manufacturers require such style for assembly with V-Cuts. This is achieved via framing type <code>tightframe</code>. Note that it does not make much sense with mousebites.</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 6mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts vcuts \\\n    --framing 'tightframe; width: 5mm; space: 3mm; ' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 6mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts vcuts ^\n    --framing \"tightframe; width: 5mm; space: 3mm; \" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Once we have a frame, we can append a tooling holes, fiducials and some text to it:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --tooling '3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm' \\\n    --fiducials '3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;' \\\n    --text 'simple; text: yaqwsx's panel; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --tooling \"3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm\" ^\n    --fiducials \"3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;\" ^\n    --text \"simple; text: yaqwsx's panel; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>If you want to add text to both rails, you can use section <code>--text2</code> to add a second text. You can also use variables enclosed in curly brackets (<code>{}</code>). The list of supported variables is listed in the documentation. Also, plugins can introduce new variables.</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --tooling '3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm' \\\n    --fiducials '3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;' \\\n    --text 'simple; text: yaqwsx's panel; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;' \\\n    --text2 'simple; text: Created on {date}; anchor: mb; voffset: -2.5mm; hjustify: center; vjustify: center;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --tooling \"3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm\" ^\n    --fiducials \"3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;\" ^\n    --text \"simple; text: yaqwsx's panel; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;\" ^\n    --text2 \"simple; text: Created on {date}; anchor: mb; voffset: -2.5mm; hjustify: center; vjustify: center;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>There are many options for text and fiducials. Be sure to read the full documentation.</p> <p>If you have an automatic feeder in your PNP machine or you just dislike sharp corners, you can add a chamfer or a fillet to the panel frame/rails:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm; fillet: 1mm' \\\n    --tooling '3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm' \\\n    --fiducials '3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm; fillet: 1mm\" ^\n    --tooling \"3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm\" ^\n    --fiducials \"3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm; chamfer: 1mm' \\\n    --tooling '3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm' \\\n    --fiducials '3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm; chamfer: 1mm\" ^\n    --tooling \"3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm\" ^\n    --fiducials \"3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Some services, e.g., JLC PCB require a minimal panel size. If you want to ensure that your panel meets the criteria, you can specify minimal total width/height of the panel. Let's see an example:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'frame; width: 5mm; space: 3mm; mintotalheight: 100mm; mintotalwidth: 100mm' \\\n    --tooling '3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm' \\\n    --fiducials '3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;' \\\n    --text 'simple; text: yaqwsx's panel with minimal dimensions; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"frame; width: 5mm; space: 3mm; mintotalheight: 100mm; mintotalwidth: 100mm\" ^\n    --tooling \"3hole; hoffset: 2.5mm; voffset: 2.5mm; size: 1.5mm\" ^\n    --fiducials \"3fid; hoffset: 5mm; voffset: 2.5mm; coppersize: 2mm; opening: 1mm;\" ^\n    --text \"simple; text: yaqwsx's panel with minimal dimensions; anchor: mt; voffset: 2.5mm; hjustify: center; vjustify: center;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p>"},{"location":"panelization/examples/#advanced-features-layouts","title":"Advanced features &amp; layouts","text":"<p>It is possible that you have some critical features you want to avoid with tabs. KiKit has several features that can help you. Let's start with the simple ones.</p> <p>First, you can rotate the boards in your layout. This might make not much sense for rectanglar boards, but it might save you when you have circular or oddly shaped boards:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 0mm; rotation: 45deg;' \\\n    --tabs 'fixed; width: 3mm;' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.75mm' \\\n    --framing 'frame; width: 5mm; space: 3mm; cuts: both' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 0mm; rotation: 45deg;\" ^\n    --tabs \"fixed; width: 3mm;\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.75mm\" ^\n    --framing \"frame; width: 5mm; space: 3mm; cuts: both\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>When your board has a connector sticking one one side of the board, it makes sense to rotate the boards every other column, row or combination of both. KiKit supports this via layout option <code>alternation</code>. You should be careful about component references when rotating boards \u2013 KiCAD's references have a property \"Stay upright\" which makes them always face up (even when placed on a panel). So be sure to turn it off before panelizing. Here's an example:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 3mm; alternation: cols;' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'frame; width: 5mm; space: 3mm; cuts: both' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 3mm; alternation: cols;\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"frame; width: 5mm; space: 3mm; cuts: both\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Another solution might be to not put tabs on, e.g., vertical edges of the PCB. However, in that case your panel might be weak for further assembly. You can make it more stiff by including backbones \u2013 a full piece of substrate between the panels. You can add either vertical, horizontal or both backbones. Also, similarly with frames, you can put cuts on your backbone to make depanelization of your boards easier. Enough theory, let's see an example</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm; hbackbone: 5mm; hbonecut: true' \\\n    --tabs 'fixed; width: 3mm; vcount: 2; hcount: 0' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm; hbackbone: 5mm; hbonecut: true\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2; hcount: 0\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Often, not all backbones are needed. Especially for larger panels. Therefore, if you want, you can skip some of them. Consider the following 4\u00d74 panel with only ever other backbone:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 4; cols: 4; space: 2mm; hbackbone: 5mm; vbackbone: 5mm; hboneskip: 1; vboneskip: 1' \\\n    --tabs 'fixed; width: 3mm; vcount: 2; hcount: 0' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 4; cols: 4; space: 2mm; hbackbone: 5mm; vbackbone: 5mm; hboneskip: 1; vboneskip: 1\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2; hcount: 0\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>The most powerful feature of KiKit regarding tab placement are tabs via annotation. Remember our test board? When you open it in Pcbnew, you can see that there are some special footprints \u2013 KiKit's annotations:</p> <p></p> <p>They specify where to place tabs. You can even specify individual tab width via text property of the symbol. How to use it? Just specify tab type to <code>annotation</code>. We also have to increase the source area tolerance, so it can capture the annotations.</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 5mm;' \\\n    --tabs annotation \\\n    --source 'tolerance: 15mm' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 5mm;\" ^\n    --tabs annotation ^\n    --source \"tolerance: 15mm\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Well, the panel looks strange \u2013 right? That's because KiKit always constructs a half-bridges. When you specify the tabs location, you have to either ensure they match or put a piece of substrate they can reach \u2013 e.g., a backbone or a tightframe. If you are interested in the details, read more about tabs in section Understanding tabs. Let's fix it:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm; hbackbone: 3mm; vbackbone: 3mm' \\\n    --tabs annotation \\\n    --source 'tolerance: 15mm' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm; hbackbone: 3mm; vbackbone: 3mm\" ^\n    --tabs annotation ^\n    --source \"tolerance: 15mm\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Note that the annotation can have an arbitrary orientation. The arrow just must be outside board edge and points towards it. KiKit will also place only those tabs, that have a neighboring substrate. For precise algorithm, see section understanding tabs.</p> <p>When you make flex PCBs or you want to save etchant, it make sense to pour copper on all non-functional parts of the panel. It will make the PCB rigid. You can do so via <code>copperfill</code> section:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm;' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --copperfill solid \\\n    --post 'millradius: 1mm;' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm;\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --copperfill solid ^\n    --post \"millradius: 1mm;\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>When you use V-cuts with <code>copperfill</code> you (or your fab house) might want to include a clearance around the V-cuts:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; hwidth: 10mm; vwidth: 15mm' \\\n    --cuts 'vcuts; clearance: 1.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --copperfill solid \\\n    --post 'millradius: 1mm;' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; hwidth: 10mm; vwidth: 15mm\" ^\n    --cuts \"vcuts; clearance: 1.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --copperfill solid ^\n    --post \"millradius: 1mm;\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>If you, for example do not wish to cover the tabs with copper, you can also specify clearance. Also, some manufacturers don't like when you have large solid copper areas. In that case, you can use a hatch pattern to fill the area:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm;' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --copperfill 'hatched; clearance: 2mm; spacing: 0.5mm; width: 0.5mm' \\\n    --post 'millradius: 1mm;' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm;\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --copperfill \"hatched; clearance: 2mm; spacing: 0.5mm; width: 0.5mm\" ^\n    --post \"millradius: 1mm;\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>Note one last facts about V-cuts. V-cuts can only be straight and horizontal/vertical. But you can use them with circular boards if you want by cutting a little inside them. The option <code>cutcurves</code>, that will approximate the cut by staring and ending point.</p>"},{"location":"panelization/examples/#i-would-like-but-kikit-does-not-support-it","title":"I would like... but KiKit does not support it!","text":"<p>If you need something special; e.g., custom placement of tooling holes, multiple texts, etc. KiKit has you covered.</p> <p>The CLI interface allows you to run a custom script over the final panel. The script can use KiKit Python interface to modify it. For the sake of simplicity, let's add a hole in the middle of the frame. Therefore, we write the following script:</p> <pre><code>from kikit.units import mm\nfrom kikit.common import toKiCADPoint\n\ndef kikitPostprocess(panel, arg):\n    minx, miny, maxx, maxy = panel.panelBBox()\n    position = toKiCADPoint(((minx + maxx) // 2, miny + 2 * mm))\n    panel.addNPTHole(position, 3 * mm)\n</code></pre> <p>Then run KiKit:</p> <p>Panelization command</p> Linux/macOSWindows <pre><code>kikit panelize \\\n    --layout 'grid; rows: 2; cols: 2; space: 2mm' \\\n    --tabs 'fixed; width: 3mm; vcount: 2' \\\n    --cuts 'mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm' \\\n    --framing 'railstb; width: 5mm; space: 3mm;' \\\n    --post 'millradius: 1mm; script: docs/resources/examplePost.py' \\\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <pre><code>kikit panelize ^\n    --layout \"grid; rows: 2; cols: 2; space: 2mm\" ^\n    --tabs \"fixed; width: 3mm; vcount: 2\" ^\n    --cuts \"mousebites; drill: 0.5mm; spacing: 1mm; offset: 0.2mm; prolong: 0.5mm\" ^\n    --framing \"railstb; width: 5mm; space: 3mm;\" ^\n    --post \"millradius: 1mm; script: docs/resources/examplePost.py\" ^\n    docs/resources/conn.kicad_pcb panel.kicad_pcb\n</code></pre> <p></p> <p>You can learn more about available functions from the comment in the source code or in the Python API reference. The basic concepts are summarized in the scripting guide.</p> <p>If you implement a feature that your fab house requires (e.g., new tooling hole type), consider submitting a pull request for KiKit instead. I believe the others will benefit from it.</p>"},{"location":"panelization/examples/#managing-presets","title":"Managing presets","text":"<p>The last section of this document is dedicated to management of presets. You can read the specification in the documentation for CLI. Here I would like to focus on practical examples.</p> <p>As you should know from the documentation, the panelization preset is divided into sections; e. g., <code>layout</code>, <code>tabs</code>, etc. The key-value parameters in these sections can be specified via JSON files. In KiKit, you can specify these files via <code>-p</code> option:</p> <p><code>kikit panelize -p myPreset.json -p :&lt;builtInPreset&gt; &lt;other parameters&gt;</code></p> <p>The parameters in the later specified presets override the parameters in the previously specified presets. This allows you to define a named piece-wise presets. Therefore, you can prepare various presets for mousebites \u2013 e.g., <code>fineMousebites.json</code> and <code>coarseMousebites.json</code>:</p> <pre><code>// fineMousebites.json\n{\n    \"cuts\": {\n        \"type\": \"mousebites\", \"drill\": \"0.5mm\", \"spacing\": \"0.9mm\", \"offset\":\n        \"0.25mm\"\n    }\n}\n\n// coarseMousebites.json\n{\n    \"cuts\": {\n        \"type\": \"mousebites\", \"drill\": \"0.3mm\", \"spacing\": \"0.2mm\", \"offset\":\n        \"0.15mm\"\n    }\n}\n</code></pre> <p>Then you can specify your panelization commands easily via:</p> <p><code>kikit panelize -p fineMousebites.json &lt;otheroptions&gt;</code></p> <p>Therefore, you can build a custom library of commonly used-options; e.g., per fabrication house. KiKit offers some built-in presets \u2013 see <code>panelizePresets</code>. Note that the built-in preset <code>default.json</code> is always used as a base and it specifies conservative default values so you can only override the options relevant for you.</p> <p>To give you an example \u2013 with KiKit, you will no longer have to remember what diameter of tooling holes JLC PCB requires, just use:</p> <p><code>kikit panelize -p :jlcTooling &lt;otheroptions&gt;</code></p>"},{"location":"panelization/gui/","title":"Panelization GUI","text":"<p>The panelization feature of KiKit is also available via GUI in the KiCAD's PCB editor (Pcbnew). The main use-case for the GUI is to quickly construct the desired KiKit command and fine-tune the panel. It also serves as a quick help in case you are not sure about parameter naming.</p> <p>The GUI is designed to be run in a standalone instance of Pcbnew (not executed from a project) as the generated panel replaces the currently open board.</p> <p>You can invoke the GUI via clicking on the panelization icon:</p> <p></p> <p>Then the following window will open:</p> <p></p> <p>There are three parts of the window:</p> <ul> <li>the left column where you can edit individual parameter sections. These   sections are in 1:1 correspondence to the panelization CLI. For the help on   their meaning please refer to CLI documentation</li> <li>the right column with:<ul> <li>the constructed KiKit command (that you can put into your Makefile)</li> <li>the constructed JSON preset that you can save and later use.</li> </ul> </li> </ul> <p>Note that both, the command and JSON preset, does not include a parameter if it is the same with the default, built-in, preset.</p> <p>Once you are happy with the parameters, you can click the \"Panelize\" button and the panel will appear in the Pcbnew work area. You can then edit the parameters and regenerate the panel. The panel you see in the Pcbnew window is only a preview. The panel is automatically saved to the specified location upon creation.</p>"},{"location":"panelization/intro/","title":"Automatic panelization with KiKit","text":"<p>KiKit panelization module is designed to:</p> <ul> <li>panelize arbirary shaped boards,</li> <li>build panels that need no further inspection, and</li> <li>create panels that pass DRC.</li> </ul> <p>There are two ways of specifying a panel:</p> <ul> <li>there is a CLI interface that should cover 98\u00a0% of use cases. It can   create panels of a single design with the most common features. It allows you   to build the panel specification out of predefined preset files. If built-in   feature is insufficient, you can override it via plugin. The features of the CLI are covered by examples. If you want, you can use GUI to rapidly prototype KiKit presets.</li> <li>for the rest of the cases there is Python API where you use   KiKit as a library in your panel building script. This is described in the   scripting section. However, at the moment, there are no proper   examples available.</li> </ul>"},{"location":"panelization/plugins/","title":"KiKit Plugins","text":"<p>To tweak the KiKit UI process it is possible to use plugins. Plugins are pieces of Python code that provide some functionality. They can save you from writing a custom panelization script from scratch when you only need a custom one of the steps during panelization.</p>"},{"location":"panelization/plugins/#specifying-plugins","title":"Specifying plugins","text":"<p>Some of the CLI options allow you to specify plugin. In such a case, one of the following formats is expected:</p> <ul> <li><code>&lt;packagename&gt;.&lt;pluginname&gt;</code>, e.g., <code>ExternalPackage.CircleLayout</code></li> <li><code>&lt;filename&gt;.&lt;pluginname&gt;</code>, e.g., <code>localFile.py.CircleLayout</code></li> </ul> <p>All plugins, except text plugins, accept optional user text argument.</p> <p>The plugins can be implemented and published as Python packages.</p>"},{"location":"panelization/plugins/#writing-custom-plugins","title":"Writing custom plugins","text":"<p>The plugins should be implemented by overriding one of the plugin types specified in <code>../kikit/plugin.py</code>. Currently, the following plugin types are supported:</p> <ul> <li><code>HookPlugin</code> - this is a plugin that features a number of callback that are   invoked during various stages of building the panel. You can tweak the panels in these callbacks.</li> <li><code>LayoutPlugin</code> - this plugin implements a new layout of the boards in the   panel.</li> <li><code>FramingPlugin</code> - this plugin implements a new style of framing.</li> <li><code>TabsPlugin</code> - this plugin implements a new style of tab placement.</li> <li><code>CutsPlugin</code> - this plugin implements a new style of cut rendering.</li> <li><code>ToolingPlugin</code> - this plugin implements a new style of tolling decoration.</li> <li><code>FiducialsPlugin</code> - this plugin implements a new style of fiducials   decoration.</li> <li><code>TextVariablePlugin</code> - this plugins provides new variables for the text   placement.</li> </ul> <p>All plugins except <code>TextVariablePlugin</code> have attributes <code>self.preset</code> containing the whole preset and <code>self.userArg</code> containing the string provided by the user.</p>"},{"location":"panelization/python_api/","title":"Panelization","text":"<p>When you want to panelize a board, you are expected to load the <code>kikit.panelize</code> module and create an instance of the <code>Panel</code> class.</p> <p>All units are in the internal KiCAD units (1 nm). You can use predefined constants to convert from/to them:</p> <pre><code>from kikit.units import *\n\nl = 1 * mm    # 1 mm\nl = 42 * inch # 42 inches\nl = 15 * cm   # 15 cm\na = 90 * deg  # 90\u00b0\na = 1 * rad   # 1 radian\n</code></pre> <p>You can also use functions <code>fromMm(mm)</code> and <code>toMm(kiUnits)</code> to convert to/from them if you like them more. You are also encouraged to use the functions and objects the native KiCAD Python API offers, e.g.: VECTOR2I(args)<code>,</code>BOX2I(args).</p>"},{"location":"panelization/python_api/#basic-concepts","title":"Basic Concepts","text":"<p>The <code>kikit.panelize.Panel</code> class holds a panel under construction. Basically it is <code>pcbnew.BOARD</code> without outlines. The outlines are held separately as <code>shapely.MultiPolygon</code> so we can easily merge pieces of a substrate, add cuts and export it back to <code>pcbnew.BOARD</code>. This is all handled by the class <code>kikit.substrate.Substrate</code>.</p>"},{"location":"panelization/python_api/#tabs","title":"Tabs","text":"<p>There are two ways to create tabs: generate a piece of a substrate by hand, or use tab generator.</p> <p>To generate a piece of a substrate, create a shapely.Polygon. Then add the piece of substrate via <code>panelize.Panel.appendSubstrate</code>. This method also accepts a <code>BOX2I</code> for convenience.</p> <p>The tab generator is available via <code>panelize.Panel.boardSubstrate.tab</code>. This method takes an origin point, direction, and tab width. It tries to build a tab by extruding a tab with the given width in the given direction and stops when it reaches an existing substrate. It returns a tuple - the tab substrate and a piece of the outline of the original board, which was removed by the tab. Then add the piece of a substrate via <code>panelize.Panel.appendSubstrate</code>. This design choice was made as batch adding of substrates is more efficient. Therefore, you are advised to first generate all the tabs and then append them to the board.</p> <p>You read more about the algorithms for generating tabs in a separate document understanding tabs.</p>"},{"location":"panelization/python_api/#cuts","title":"Cuts","text":"<p>All methods constructing panels do not create cuts directly, instead, they return them. This allows the users to decided how to perform the cuts - e.g., mouse bites, V-Cuts, silk-screen...</p> <p>The cuts are represented by <code>shapely.LineString</code>. The string is oriented - a positive side of the string should face the inner side of the board. This is important when, e.g., offsetting mouse bites.</p> <p>To perform the cuts, see methods of the <code>panelize.Panel</code> class below.</p>"},{"location":"panelization/python_api/#source-area-and-tolerance","title":"Source Area And Tolerance","text":"<p>When placing a board, you might specify source area -- a rectangle from which the components are extracted. If no source area is specified, the smallest bounding box of all Edge.Cuts is taken.</p> <p>Only components that fully fit inside source area are copied to the panel. To include components sticking out of the board outline, you can specify tolerance -- a distance by which the source area is expanded when copying components.</p>"},{"location":"panelization/python_api/#appendboard","title":"<code>appendBoard</code>","text":"<pre><code>appendBoard(self, filename, destination, sourceArea=None, origin=Origin.Center, \n            rotationAngle=&lt;pcbnew.EDA_ANGLE; proxy of &lt;Swig Object of type 'EDA_ANGLE *' at 0x7f4b833f3120&gt; &gt;, \n            shrink=False, tolerance=0, bufferOutline=1000, netRenamer=None, \n            refRenamer=None, inheritDrc=True, interpretAnnotations=True, \n            bakeText=False)\n</code></pre>"},{"location":"panelization/python_api/#panel-class","title":"Panel class","text":"<p>This class has the following relevant members: - <code>board</code> - <code>pcbnew.BOARD</code> of the panel. Does not contain any edges. - <code>substrates</code> - <code>kikit.substrate.Substrate</code> - individual substrates appended   via <code>None</code>. You can use them to get the   original outline (and e.g., generate tabs accroding to it). - <code>boardSubstrate</code> - <code>kikit.substrate.Substrate</code> of the whole panel. - <code>backboneLines</code> - a list of lines representing backbone candidates. Read more   about it in understanding tabs.</p>"},{"location":"panelization/python_api/#addcornerchamfers","title":"<code>addCornerChamfers</code>","text":"<p><pre><code>addCornerChamfers(self, horizontalSize, verticalSize=None)\n</code></pre> Add chamfers to the panel frame. The chamfer is specified as size in horizontal and vertical direction. If you specify only the horizontal one, the chamfering will be 45\u00b0.</p>"},{"location":"panelization/python_api/#addcornerfiducials","title":"<code>addCornerFiducials</code>","text":"<p><pre><code>addCornerFiducials(self, fidCount, horizontalOffset, verticalOffset, \n                   copperDiameter, openingDiameter, paste=False)\n</code></pre> Add up to 4 fiducials to the top-left, top-right, bottom-left and bottom-right corner of the board (in this order). This function expects there is enough space on the board/frame/rail to place the feature.</p> <p>The offsets are measured from the outer edges of the substrate.</p>"},{"location":"panelization/python_api/#addcornerfillets","title":"<code>addCornerFillets</code>","text":"<p><pre><code>addCornerFillets(self, radius)\n</code></pre> None</p>"},{"location":"panelization/python_api/#addcornertooling","title":"<code>addCornerTooling</code>","text":"<p><pre><code>addCornerTooling(self, holeCount, horizontalOffset, verticalOffset, diameter, \n                 paste=False, solderMaskMargin=None)\n</code></pre> Add up to 4 tooling holes to the top-left, top-right, bottom-left and bottom-right corner of the board (in this order). This function expects there is enough space on the board/frame/rail to place the feature.</p> <p>The offsets are measured from the outer edges of the substrate.</p> <p>Optionally, a solder mask margin (diameter) can also be specified.</p>"},{"location":"panelization/python_api/#addfiducial","title":"<code>addFiducial</code>","text":"<p><pre><code>addFiducial(self, position, copperDiameter, openingDiameter, bottom=False, \n            paste=False, ref=None)\n</code></pre> Add fiducial, i.e round copper pad with solder mask opening to the position (<code>VECTOR2I</code>), with given copperDiameter and openingDiameter. By setting bottom to True, the fiducial is placed on bottom side. The fiducial can also have an opening on the stencil. This is enabled by paste = True.</p>"},{"location":"panelization/python_api/#addkeepout","title":"<code>addKeepout</code>","text":"<p><pre><code>addKeepout(self, area, noTracks=True, noVias=True, noCopper=True)\n</code></pre> Add a keepout area to all copper layers. Area is a shapely polygon. Return the keepout area.</p>"},{"location":"panelization/python_api/#addline","title":"<code>addLine</code>","text":"<p><pre><code>addLine(self, start, end, thickness, layer)\n</code></pre> Add a line to the panel based on starting and ending point</p>"},{"location":"panelization/python_api/#addmillfillets","title":"<code>addMillFillets</code>","text":"<p><pre><code>addMillFillets(self, millRadius)\n</code></pre> Add fillets to inner conernes which will be produced a by mill with given radius. This operation simulares milling.</p>"},{"location":"panelization/python_api/#addnpthole","title":"<code>addNPTHole</code>","text":"<p><pre><code>addNPTHole(self, position, diameter, paste=False, ref=None, \n           excludedFromPos=False)\n</code></pre> Add a drilled non-plated hole to the position (<code>VECTOR2I</code>) with given diameter. The paste option allows to place the hole on the paste layers.</p>"},{"location":"panelization/python_api/#addpaneldimensions","title":"<code>addPanelDimensions</code>","text":"<p><pre><code>addPanelDimensions(self, layer, offset)\n</code></pre> Add vertial and horizontal dimensions to the panel</p>"},{"location":"panelization/python_api/#addtabmillfillets","title":"<code>addTabMillFillets</code>","text":"<p><pre><code>addTabMillFillets(self, millRadius)\n</code></pre> Add fillets to inner conernes which will be produced a by mill with given radius. Simulates milling only on the outside of the board; internal features of the board are not affected.</p>"},{"location":"panelization/python_api/#addtext","title":"<code>addText</code>","text":"<p><pre><code>addText(self, text, position, \n        orientation=&lt;pcbnew.EDA_ANGLE; proxy of &lt;Swig Object of type 'EDA_ANGLE *' at 0x7f4b833f37b0&gt; &gt;, \n        width=1500000, height=1500000, thickness=300000, \n        hJustify=EDA_TEXT_HJUSTIFY_T.GR_TEXT_HJUSTIFY_CENTER, \n        vJustify=EDA_TEXT_VJUSTIFY_T.GR_TEXT_VJUSTIFY_CENTER, \n        layer=Layer.F_SilkS)\n</code></pre> Add text at given position to the panel. If appending to the bottom side, text is automatically mirrored.</p>"},{"location":"panelization/python_api/#addvcuth","title":"<code>addVCutH</code>","text":"<p><pre><code>addVCutH(self, pos)\n</code></pre> Adds a horizontal V-CUT at pos (integer in KiCAD units).</p>"},{"location":"panelization/python_api/#addvcutv","title":"<code>addVCutV</code>","text":"<p><pre><code>addVCutV(self, pos)\n</code></pre> Adds a horizontal V-CUT at pos (integer in KiCAD units).</p>"},{"location":"panelization/python_api/#appendboard_1","title":"<code>appendBoard</code>","text":"<p><pre><code>appendBoard(self, filename, destination, sourceArea=None, origin=Origin.Center, \n            rotationAngle=&lt;pcbnew.EDA_ANGLE; proxy of &lt;Swig Object of type 'EDA_ANGLE *' at 0x7f4b833f3120&gt; &gt;, \n            shrink=False, tolerance=0, bufferOutline=1000, netRenamer=None, \n            refRenamer=None, inheritDrc=True, interpretAnnotations=True, \n            bakeText=False)\n</code></pre> Appends a board to the panel.</p> <p>The sourceArea (BOX2I) of the board specified by filename is extracted and placed at destination (VECTOR2I). The source area (BOX2I) can be auto detected if it is not provided. Only board items which fit entirely into the source area are selected. You can also specify rotation. Both translation and rotation origin are specified by origin. Origin specifies which point of the sourceArea is used for translation and rotation (origin it is placed to destination). It is possible to specify coarse source area and automatically shrink it if shrink is True. Tolerance enlarges (even shrinked) source area - useful for inclusion of filled zones which can reach out of the board edges or footprints that extend outside the board outline, like connectors.</p> <p>You can also specify functions which will rename the net and ref names. By default, nets are renamed to \"Board_{n}-{orig}\", refs are unchanged. The renamers are given board seq number and original name.</p> <p>You can also decide whether you would like to inherit design rules from this boards or not.</p> <p>Similarly, you can substitute variables in the text via bakeText.</p> <p>Returns bounding box (BOX2I) of the extracted area placed at the destination and the extracted substrate of the board.</p>"},{"location":"panelization/python_api/#appendsubstrate","title":"<code>appendSubstrate</code>","text":"<p><pre><code>appendSubstrate(self, substrate)\n</code></pre> Append a piece of substrate or a list of pieces to the panel. Substrate can be either BOX2I or Shapely polygon. Newly appended corners can be rounded by specifying non-zero filletRadius.</p>"},{"location":"panelization/python_api/#apply","title":"<code>apply</code>","text":"<p><pre><code>apply(self, feature)\n</code></pre> Apply given feature to the panel</p>"},{"location":"panelization/python_api/#boardsbbox","title":"<code>boardsBBox</code>","text":"<p><pre><code>boardsBBox(self)\n</code></pre> Return common bounding box for all boards in the design (ignores the individual pieces of substrate) as a shapely box.</p>"},{"location":"panelization/python_api/#buildfulltabs","title":"<code>buildFullTabs</code>","text":"<p><pre><code>buildFullTabs(self, cutoutDepth, patchCorners=True)\n</code></pre> Make full tabs. This strategy basically cuts the bounding boxes of the PCBs. Not suitable for mousebites or PCB that doesn't have a rectangular outline. Expects there is a valid partition line.</p> <p>Return a list of cuts.</p>"},{"location":"panelization/python_api/#buildpartitionlinefrombb","title":"<code>buildPartitionLineFromBB</code>","text":"<p><pre><code>buildPartitionLineFromBB(self, boundarySubstrates=[], safeMargin=0)\n</code></pre> Builds partition &amp; backbone line from bounding boxes of the substrates. You can optionally pass extra substrates (e.g., for frame). Without these extra substrates no partition line would be generated on the side where the boundary is, therefore, there won't be any tabs.</p>"},{"location":"panelization/python_api/#buildtabannotationscorners","title":"<code>buildTabAnnotationsCorners</code>","text":"<p><pre><code>buildTabAnnotationsCorners(self, width)\n</code></pre> Add tab annotations to the corners of the individual substrates.</p>"},{"location":"panelization/python_api/#buildtabannotationsfixed","title":"<code>buildTabAnnotationsFixed</code>","text":"<p><pre><code>buildTabAnnotationsFixed(self, hcount, vcount, hwidth, vwidth, minDistance, \n                         ghostSubstrates)\n</code></pre> Add tab annotations for the individual substrates based on number of tabs in horizontal and vertical direction. You can specify individual width in each direction.</p> <p>If the edge is short for the specified number of tabs with given minimal spacing, the count is reduced.</p> <p>You can also specify ghost substrates (for the future framing).</p>"},{"location":"panelization/python_api/#buildtabannotationsspacing","title":"<code>buildTabAnnotationsSpacing</code>","text":"<p><pre><code>buildTabAnnotationsSpacing(self, spacing, hwidth, vwidth, ghostSubstrates)\n</code></pre> Add tab annotations for the individual substrates based on their spacing.</p> <p>You can also specify ghost substrates (for the future framing).</p>"},{"location":"panelization/python_api/#buildtabsfromannotations","title":"<code>buildTabsFromAnnotations</code>","text":"<p><pre><code>buildTabsFromAnnotations(self, fillet)\n</code></pre> Given annotations for the individual substrates, create tabs for them. Tabs are appended to the panel, cuts are returned.</p> <p>Expects that a valid partition line is assigned to the the panel.</p>"},{"location":"panelization/python_api/#cleartabsannotations","title":"<code>clearTabsAnnotations</code>","text":"<p><pre><code>clearTabsAnnotations(self)\n</code></pre> Remove all existing tab annotations from the panel.</p>"},{"location":"panelization/python_api/#copperfillnonboardareas","title":"<code>copperFillNonBoardAreas</code>","text":"<p><pre><code>copperFillNonBoardAreas(self, clearance=1000000, \n                        layers=[&lt;Layer.F_Cu: 0&gt;, &lt;Layer.B_Cu: 31&gt;], \n                        hatched=False, strokeWidth=1000000, \n                        strokeSpacing=1000000, \n                        orientation=&lt;pcbnew.EDA_ANGLE; proxy of &lt;Swig Object of type 'EDA_ANGLE *' at 0x7f4b833f3510&gt; &gt;)\n</code></pre> This function is deprecated, please, use panel features instead.</p> <p>Fill given layers with copper on unused areas of the panel (frame, rails and tabs). You can specify the clearance, if it should be hatched (default is solid) or shape the strokes of hatched pattern.</p> <p>By default, fills top and bottom layer, but you can specify any other copper layer that is enabled.</p>"},{"location":"panelization/python_api/#debugrenderbackbonelines","title":"<code>debugRenderBackboneLines</code>","text":"<p><pre><code>debugRenderBackboneLines(self)\n</code></pre> Render partition line to the panel to be easily able to inspect them via Pcbnew.</p>"},{"location":"panelization/python_api/#debugrenderboundingboxes","title":"<code>debugRenderBoundingBoxes</code>","text":"<p><pre><code>debugRenderBoundingBoxes(self)\n</code></pre> None</p>"},{"location":"panelization/python_api/#debugrenderpartitionlines","title":"<code>debugRenderPartitionLines</code>","text":"<p><pre><code>debugRenderPartitionLines(self)\n</code></pre> Render partition line to the panel to be easily able to inspect them via Pcbnew.</p>"},{"location":"panelization/python_api/#getauxiliaryorigin","title":"<code>getAuxiliaryOrigin</code>","text":"<p><pre><code>getAuxiliaryOrigin(self)\n</code></pre> None</p>"},{"location":"panelization/python_api/#getdrufilepath","title":"<code>getDruFilepath</code>","text":"<p><pre><code>getDruFilepath(self, path=None)\n</code></pre> None</p>"},{"location":"panelization/python_api/#getgridorigin","title":"<code>getGridOrigin</code>","text":"<p><pre><code>getGridOrigin(self)\n</code></pre> None</p>"},{"location":"panelization/python_api/#getpagedimensions","title":"<code>getPageDimensions</code>","text":"<p><pre><code>getPageDimensions(self)\n</code></pre> Get page size in KiCAD units for the current panel</p>"},{"location":"panelization/python_api/#getprlfilepath","title":"<code>getPrlFilepath</code>","text":"<p><pre><code>getPrlFilepath(self, path=None)\n</code></pre> None</p>"},{"location":"panelization/python_api/#getprofilepath","title":"<code>getProFilepath</code>","text":"<p><pre><code>getProFilepath(self, path=None)\n</code></pre> None</p>"},{"location":"panelization/python_api/#inheritcopperlayers","title":"<code>inheritCopperLayers</code>","text":"<p><pre><code>inheritCopperLayers(self, board)\n</code></pre> Update the panel's layer count to match the design being panelized. Raise an error if this is attempted twice with inconsistent layer count boards.</p>"},{"location":"panelization/python_api/#inheritdesignsettings","title":"<code>inheritDesignSettings</code>","text":"<p><pre><code>inheritDesignSettings(self, board)\n</code></pre> Inherit design settings from the given board specified by a filename or a board</p>"},{"location":"panelization/python_api/#inheritpagesize","title":"<code>inheritPageSize</code>","text":"<p><pre><code>inheritPageSize(self, board)\n</code></pre> Inherit page size from a board specified by a filename or a board</p>"},{"location":"panelization/python_api/#inheritproperties","title":"<code>inheritProperties</code>","text":"<p><pre><code>inheritProperties(self, board)\n</code></pre> Inherit text properties from a board specified by a filename or a board</p>"},{"location":"panelization/python_api/#inherittitleblock","title":"<code>inheritTitleBlock</code>","text":"<p><pre><code>inheritTitleBlock(self, board)\n</code></pre> Inherit title block from a board specified by a filename or a board</p>"},{"location":"panelization/python_api/#locateboard","title":"<code>locateBoard</code>","text":"<p><pre><code>locateBoard(inputFilename, expandDist=None)\n</code></pre> Given a board filename, find its source area and optionally expand it by the given distance.</p> <p>Parameters:</p> <p>inputFilename - the path to the board file</p> <p>expandDist - the distance by which to expand the board outline in each direction to ensure elements that are outside the board are included</p>"},{"location":"panelization/python_api/#makecutstolayer","title":"<code>makeCutsToLayer</code>","text":"<p><pre><code>makeCutsToLayer(self, cuts, layer=Layer.Cmts_User, prolongation=0)\n</code></pre> Take a list of cuts and render them as lines on given layer. The cuts can be prolonged just like with mousebites.</p> <p>The purpose of this is to aid debugging when KiKit refuses to perform cuts. Rendering them into lines can give the user better understanding of where is the problem.</p>"},{"location":"panelization/python_api/#makeframe","title":"<code>makeFrame</code>","text":"<p><pre><code>makeFrame(self, width, hspace, vspace, minWidth=0, minHeight=0, maxWidth=None, \n          maxHeight=None)\n</code></pre> Build a frame around the boards. Specify width and spacing between the boards substrates and the frame. Return a tuple of vertical and horizontal cuts.</p> <p>Parameters:</p> <p>width - width of substrate around board outlines</p> <p>slotwidth - width of milled-out perimeter around board outline</p> <p>hspace - horizontal space between board outline and substrate</p> <p>vspace - vertical space between board outline and substrate</p> <p>minWidth - if the panel doesn't meet this width, it is extended</p> <p>minHeight - if the panel doesn't meet this height, it is extended</p> <p>maxWidth - if the panel doesn't meet this width, TooLargeError is raised</p> <p>maxHeight - if the panel doesn't meet this height, TooLargeHeight is raised</p>"},{"location":"panelization/python_api/#makeframecutsh","title":"<code>makeFrameCutsH</code>","text":"<p><pre><code>makeFrameCutsH(self, innerArea, frameInnerArea, outerArea)\n</code></pre> Generate horizontal cuts for the frame corners and return them</p>"},{"location":"panelization/python_api/#makeframecutsv","title":"<code>makeFrameCutsV</code>","text":"<p><pre><code>makeFrameCutsV(self, innerArea, frameInnerArea, outerArea)\n</code></pre> Generate vertical cuts for the frame corners and return them</p>"},{"location":"panelization/python_api/#makegrid","title":"<code>makeGrid</code>","text":"<p><pre><code>makeGrid(self, boardfile, sourceArea, rows, cols, destination, placer, \n         rotation=&lt;pcbnew.EDA_ANGLE; proxy of &lt;Swig Object of type 'EDA_ANGLE *' at 0x7f4b833f3f00&gt; &gt;, \n         netRenamePattern=Board_{n}-{orig}, refRenamePattern=Board_{n}-{orig}, \n         tolerance=0, bakeText=False)\n</code></pre> Place the given board in a grid pattern with given spacing. The board position of the gride is guided via placer. The nets and references are renamed according to the patterns.</p> <p>Parameters:</p> <p>boardfile - the path to the filename of the board to be added</p> <p>sourceArea - the region within the file specified to be selected (see also tolerance, below)     set to None to automatically calculate the board area from the board     file with the given tolerance</p> <p>rows - the number of boards to place in the vertical direction</p> <p>cols - the number of boards to place in the horizontal direction</p> <p>destination - the center coordinates of the first board in the grid (for example, VECTOR2I(100 * mm, 50 * mm))</p> <p>rotation - the rotation angle to be applied to the source board before placing it</p> <p>placer - the placement rules for boards. The builtin classes are:     BasicGridPosition - places each board in its original orientation     OddEvenColumnPosition - every second column has the boards rotated     by 180 degrees OddEvenRowPosition - every second row has the boards     rotated by 180 degrees OddEvenRowsColumnsPosition - every second row     and column has the boards rotated by 180 degrees</p> <p>netRenamePattern - the pattern according to which the net names are transformed     The default pattern is \"Board_{n}-{orig}\" which gives each board its     own instance of its nets, i.e. GND becomes Board_0-GND for the first     board , and Board_1-GND for the second board etc</p> <p>refRenamePattern - the pattern according to which the reference designators are transformed     The default pattern is \"Board_{n}-{orig}\" which gives each board its     own instance of its reference designators, so R1 becomes Board_0-R1     for the first board, Board_1-R1 for the second board etc. To keep     references the same as in the original, set this to \"{orig}\"</p> <p>tolerance - if no sourceArea is specified, the distance by which the selection     area for the board should extend outside the board edge. If you have     any objects that are on or outside the board edge, make sure this is     big enough to include them. Such objects often include zone outlines     and connectors.</p> <p>bakeText - substitute variables in text elements</p> <p>Returns a list of the placed substrates. You can use these to generate tabs, frames, backbones, etc.</p>"},{"location":"panelization/python_api/#makelayersvisible","title":"<code>makeLayersVisible</code>","text":"<p><pre><code>makeLayersVisible(self)\n</code></pre> Modify corresponding *.prl files so all the layers are visible by default</p>"},{"location":"panelization/python_api/#makemousebites","title":"<code>makeMouseBites</code>","text":"<p><pre><code>makeMouseBites(self, cuts, diameter, spacing, offset=250000, prolongation=500000)\n</code></pre> Take a list of cuts and perform mouse bites. The cuts can be prolonged to</p>"},{"location":"panelization/python_api/#makerailslr","title":"<code>makeRailsLr</code>","text":"<p><pre><code>makeRailsLr(self, thickness, minWidth=0, maxWidth=None)\n</code></pre> Adds a rail to left and right. You can specify minimal width the panel has to feature.</p>"},{"location":"panelization/python_api/#makerailstb","title":"<code>makeRailsTb</code>","text":"<p><pre><code>makeRailsTb(self, thickness, minHeight=0, maxHeight=None)\n</code></pre> Adds a rail to top and bottom. You can specify minimal height the panel has to feature. You can also specify maximal height of the panel. If the height would be exceeded, TooLargeError is raised.</p>"},{"location":"panelization/python_api/#maketightframe","title":"<code>makeTightFrame</code>","text":"<p><pre><code>makeTightFrame(self, width, slotwidth, hspace, vspace, minWidth=0, minHeight=0, \n               maxWidth=None, maxHeight=None)\n</code></pre> Build a full frame with board perimeter milled out. Add your boards to the panel first using appendBoard or makeGrid.</p> <p>Parameters:</p> <p>width - width of substrate around board outlines</p> <p>slotwidth - width of milled-out perimeter around board outline</p> <p>hspace - horizontal space between board outline and substrate</p> <p>vspace - vertical space between board outline and substrate</p> <p>minWidth - if the panel doesn't meet this width, it is extended</p> <p>minHeight - if the panel doesn't meet this height, it is extended</p> <p>maxWidth - if the panel doesn't meet this width, TooLargeError is raised</p> <p>maxHeight - if the panel doesn't meet this height, TooLargeHeight is raised</p>"},{"location":"panelization/python_api/#makevcuts","title":"<code>makeVCuts</code>","text":"<p><pre><code>makeVCuts(self, cuts, boundCurves=False, offset=0)\n</code></pre> Take a list of lines to cut and performs V-CUTS. When boundCurves is set, approximate curved cuts by a line from the first and last point. Otherwise, raise an exception.</p>"},{"location":"panelization/python_api/#panelbbox","title":"<code>panelBBox</code>","text":"<p><pre><code>panelBBox(self)\n</code></pre> Return bounding box of the panel as a shapely box.</p>"},{"location":"panelization/python_api/#panelcorners","title":"<code>panelCorners</code>","text":"<p><pre><code>panelCorners(self, horizontalOffset=0, verticalOffset=0)\n</code></pre> Return the list of top-left, top-right, bottom-left and bottom-right corners of the panel. You can specify offsets.</p>"},{"location":"panelization/python_api/#renderbackbone","title":"<code>renderBackbone</code>","text":"<p><pre><code>renderBackbone(self, vthickness, hthickness, vcut, hcut, vskip=0, hskip=0, \n               vfirst=0, hfirst=0)\n</code></pre> Render horizontal and vertical backbone lines. If zero thickness is specified, no backbone is rendered.</p> <p>vcut, hcut specifies if vertical or horizontal backbones should be cut.</p> <p>vskip and hskip specify how many backbones should be skipped before rendering one (i.e., skip 1 meand that every other backbone will be rendered)</p> <p>vfirst and hfirst are indices of the first backbone to render. They are 1-indexed.</p> <p>Return a list of cuts</p>"},{"location":"panelization/python_api/#save","title":"<code>save</code>","text":"<p><pre><code>save(self, reconstructArcs=False, refillAllZones=False)\n</code></pre> Saves the panel to a file and makes the requested changes to the prl and pro files.</p>"},{"location":"panelization/python_api/#setauxiliaryorigin","title":"<code>setAuxiliaryOrigin</code>","text":"<p><pre><code>setAuxiliaryOrigin(self, point)\n</code></pre> Set the auxiliary origin used e.g., for drill files</p>"},{"location":"panelization/python_api/#setcopperlayers","title":"<code>setCopperLayers</code>","text":"<p><pre><code>setCopperLayers(self, count)\n</code></pre> Sets the copper layer count of the panel</p>"},{"location":"panelization/python_api/#setdesignsettings","title":"<code>setDesignSettings</code>","text":"<p><pre><code>setDesignSettings(self, designSettings)\n</code></pre> Set design settings</p>"},{"location":"panelization/python_api/#setgridorigin","title":"<code>setGridOrigin</code>","text":"<p><pre><code>setGridOrigin(self, point)\n</code></pre> Set grid origin</p>"},{"location":"panelization/python_api/#setpagesize","title":"<code>setPageSize</code>","text":"<p><pre><code>setPageSize(self, size)\n</code></pre> Set page size - either a string name (e.g., A4) or size in KiCAD units</p>"},{"location":"panelization/python_api/#setproperties","title":"<code>setProperties</code>","text":"<p><pre><code>setProperties(self, properties)\n</code></pre> Set text properties cached in the board</p>"},{"location":"panelization/python_api/#settitleblock","title":"<code>setTitleBlock</code>","text":"<p><pre><code>setTitleBlock(self, titleBlock)\n</code></pre> Set panel title block</p>"},{"location":"panelization/python_api/#setvcutclearance","title":"<code>setVCutClearance</code>","text":"<p><pre><code>setVCutClearance(self, clearance)\n</code></pre> Set V-cut clearance</p>"},{"location":"panelization/python_api/#setvcutlayer","title":"<code>setVCutLayer</code>","text":"<p><pre><code>setVCutLayer(self, layer)\n</code></pre> Set layer on which the V-Cuts will be rendered</p>"},{"location":"panelization/python_api/#transferprojectsettings","title":"<code>transferProjectSettings</code>","text":"<p><pre><code>transferProjectSettings(self)\n</code></pre> Examine DRC rules of the source boards, merge them into a single set of rules and store them in *.kicad_pro file. Also stores board DRC exclusions.</p> <p>Also, transfers the list of net classes from the internal representation into the project file.</p>"},{"location":"panelization/python_api/#translate","title":"<code>translate</code>","text":"<p><pre><code>translate(self, vec)\n</code></pre> Translates the whole panel by vec. Such a feature can be useful to specify the panel placement in the sheet. When we translate panel as the last operation, none of the operations have to be placement-aware.</p>"},{"location":"panelization/python_api/#writecustomdrcrules","title":"<code>writeCustomDrcRules</code>","text":"<p><pre><code>writeCustomDrcRules(self)\n</code></pre> None</p>"},{"location":"panelization/python_api/#substrate-class","title":"Substrate class","text":"<p>This class represents a pice of substrate (with no components). Basically it is just a relatively thin wrapper around shapely polygons. On top of that, it keeps a partition line for the substrate. Read more about partition lines in understanding tabs.</p>"},{"location":"panelization/python_api/#backtosource","title":"<code>backToSource</code>","text":"<p><pre><code>backToSource(self, point)\n</code></pre> Return a point in the source form (if a reverse transformation was set)</p>"},{"location":"panelization/python_api/#boundary","title":"<code>boundary</code>","text":"<p><pre><code>boundary(self)\n</code></pre> Return shapely geometry representing the outer ring</p>"},{"location":"panelization/python_api/#boundingbox","title":"<code>boundingBox</code>","text":"<p><pre><code>boundingBox(self)\n</code></pre> Return bounding box as BOX2I</p>"},{"location":"panelization/python_api/#bounds","title":"<code>bounds</code>","text":"<p><pre><code>bounds(self)\n</code></pre> Return shapely bounds of substrates</p>"},{"location":"panelization/python_api/#cut","title":"<code>cut</code>","text":"<p><pre><code>cut(self, piece)\n</code></pre> Remove a piece of substrate given a shapely polygon.</p>"},{"location":"panelization/python_api/#exterior","title":"<code>exterior</code>","text":"<p><pre><code>exterior(self)\n</code></pre> Return a geometry representing the substrate with no holes</p>"},{"location":"panelization/python_api/#exteriorring","title":"<code>exteriorRing</code>","text":"<p><pre><code>exteriorRing(self)\n</code></pre> None</p>"},{"location":"panelization/python_api/#interiors","title":"<code>interiors</code>","text":"<p><pre><code>interiors(self)\n</code></pre> Return shapely interiors of the substrate</p>"},{"location":"panelization/python_api/#issinglepiece","title":"<code>isSinglePiece</code>","text":"<p><pre><code>isSinglePiece(self)\n</code></pre> Decide whether the substrate consists of a single piece</p>"},{"location":"panelization/python_api/#midpoint","title":"<code>midpoint</code>","text":"<p><pre><code>midpoint(self)\n</code></pre> Return a mid point of the bounding box</p>"},{"location":"panelization/python_api/#millfillets","title":"<code>millFillets</code>","text":"<p><pre><code>millFillets(self, millRadius)\n</code></pre> Add fillets to inner corners which will be produced by a mill with given radius.</p>"},{"location":"panelization/python_api/#orient","title":"<code>orient</code>","text":"<p><pre><code>orient(self)\n</code></pre> Ensures that the substrate is oriented in a correct way.</p>"},{"location":"panelization/python_api/#removeislands","title":"<code>removeIslands</code>","text":"<p><pre><code>removeIslands(self)\n</code></pre> Removes all islands - pieces of substrate fully contained within the outline of another board</p>"},{"location":"panelization/python_api/#serialize","title":"<code>serialize</code>","text":"<p><pre><code>serialize(self, reconstructArcs=False)\n</code></pre> Produces a list of PCB_SHAPE on the Edge.Cuts layer</p>"},{"location":"panelization/python_api/#tab","title":"<code>tab</code>","text":"<p><pre><code>tab(self, origin, direction, width, partitionLine=None, maxHeight=50000000, \n    fillet=0)\n</code></pre> Create a tab for the substrate. The tab starts at the specified origin (2D point) and tries to penetrate existing substrate in direction (a 2D vector). The tab is constructed with given width. If the substrate is not penetrated within maxHeight, exception is raised.</p> <p>When partitionLine is specified, the tab is extended to the opposite side - limited by the partition line. Note that if tab cannot span towards the partition line, then the tab is not created - it returns a tuple (None, None).</p> <p>If a fillet is specified, it allows you to add fillet to the tab of specified radius.</p> <p>Returns a pair tab and cut outline. Add the tab it via union - batch adding of geometry is more efficient.</p>"},{"location":"panelization/python_api/#translate_1","title":"<code>translate</code>","text":"<p><pre><code>translate(self, vec)\n</code></pre> Translate substrate by vec</p>"},{"location":"panelization/python_api/#union","title":"<code>union</code>","text":"<p><pre><code>union(self, other)\n</code></pre> Appends a substrate, polygon or list of polygons. If there is a common intersection, with existing substrate, it will be merged into a single substrate.</p>"},{"location":"panelization/scripting/","title":"Introduction to scripting with KiKit","text":"<p>This document will show you how to use KiKit as a library for panelization. The full reference for the available API is located in the next section.</p>"},{"location":"panelization/scripting/#basic-concepts","title":"Basic concepts","text":"<p>Let's start with an overview of the foundational concepts in KiKit.</p>"},{"location":"panelization/scripting/#units","title":"Units","text":"<p>All units are in the internal KiCAD units (1 nm). You can use predefined constants to convert from/to them:</p> <pre><code>from kikit.units import *\n\nl = 1 * mm    # 1 mm\nl = 42 * inch # 42 inches\nl = 15 * cm   # 15 cm\na = 90 * deg  # 90\u00b0\na = 1 * rad   # 1 radian\n</code></pre> <p>You can also use functions <code>fromMm(mm)</code> and <code>toMm(kiUnits)</code> to convert to/from them if you like them more. You are also encouraged to use the functions and objects that the native KiCAD Python API offers, e.g.: <code>pcbnew.wxPoint(args)</code>, <code>pcbnew.wxPointMM(mmx, mmy)</code>, <code>pcbnew.wxRect(args)</code>, <code>pcbnew.wxRectMM(x, y, wx, wy)</code>.</p>"},{"location":"panelization/scripting/#substrate","title":"Substrate","text":"<p>When KiKit loads a KiCAD board, it takes the Edge.Cuts layer and tries to interpret it as a set of 2D polygons. If it cannot interpret them (i.e, there is a discontinuous outline), it raises an exception.</p> <p>These polygons has a notion of what is inside and what is outside. We can also perform boolean operation on them (i.e., merge two polygons, subtract one from the other, etc.). When we save the panel, the polygons are converted back to outlines. All internal operations in KiKit that changes the board shape operate on top of the polygonal representation, not the outline themselves.</p> <p>The polygonal representation of board shape is called PCB substrate and it is represented by the class <code>kikit.substrate.Substrate</code>. Internally, KiKit uses the library Shapely to represent the polygon. We advise you to get at least briefly familiar with it as whenever you need to create a new piece of substrate (e.g., for a tab) you will do so using the operations Shapely provides.</p> <p>The <code>Substrate</code> class encapsulates the functionality regarding converting an outline into a polygon and vice-versa and modification of the substrate (add/subtract from it/construct a tab for it). For convenience, it also holds the partition lines associated with the substrate. For more details about partition lines, please refer to section Tabs below.</p>"},{"location":"panelization/scripting/#panel","title":"Panel","text":"<p>The panel construction is handled via <code>kikit.panelize.Panel</code> class. This class represents a panel under construction as <code>pcbnew.Board</code> without outlines. The outlines are represented via a substrate and it is converted into outline only on saving the panel to file.</p> <p>The panel class provides you with a number of methods to construct the panel; e.g., append a board at given coordinates, create a grid of boards, add piece of substrate to it, add framing, create a cut, etc.</p> <p>A typical workflow with the <code>Panel</code> class is the following:</p> <ul> <li>create an instance of the class,</li> <li>append boards to it (via <code>appendBoard</code> or <code>makeAGrid</code>),</li> <li>once all boards are appended, a partition line should be constructed via   calling <code>buildPartitionLineFromBB</code> or manually set. Without a partition line   the automatic tab building nor backbone do not work.</li> <li>create tabs:<ul> <li>you can append a pieces of substrate as you need (you will have to   specify your cuts manually), and/or</li> <li>you can place annotations where the tabs should be and render those   automatically (including cuts).</li> </ul> </li> <li>create a framing and place any other features of the tab (tooling holes,   fiducials, text markings, backbone),</li> <li>render cuts from lines to features (e.g., mouse bites),</li> <li>post-process the panel (e.g, specify a copper fill, simulate milling),</li> <li>save the panel.</li> </ul> <p>During the whole process you can directly access <code>panel.board</code> of the type <code>pcbnew.Board</code> and use the KiCAD API to add or remove the features on the boards.</p>"},{"location":"panelization/scripting/#tabs-partition-line","title":"Tabs &amp; Partition line","text":"<p>Every tab consists of two features: a piece of substrate that connects the individual board on the panel and a cut that will be broken when you depanelize the board.</p> <p>In KiKit, the substrate is represented as a <code>Substrate</code>, more precisely as <code>shapely.geometry.Polygon</code>. This substrate is appended to the resulting panel substrate. The cut is represented as a polyline of the type <code>shapely.geometry.LineString</code>. KiKit accepts the polyline and it can either convert it into mouse bites or V-cuts.</p> <p>You can build the tab substrate and cuts manually. In that case, just build the tab shape as <code>Polygon</code> and append it to the board via <code>Panel.appendSubstrate</code>. You also construct the cuts manually as <code>LineString</code> and you turn it</p> <ul> <li>into mousebites via <code>Panel.makeMouseBites</code>, or</li> <li>into V-cuts via <code>Panel.makeVCuts</code>. You can also use <code>Panel.addVCutV</code> or   <code>Panel.addVCutH</code> in this case and avoid creating the <code>LineString</code>.</li> </ul> <p>You will use this approach in the simple cases or cases when you need a specially shaped tabs.</p> <p>The second approach is to let KiKit generate the tabs and cuts automatically based on annotations. Annotation is just a marking on the board outline that specifies \"here should be a tab of this width\". You can read the annotations from source board (there are special footprints for that), generate it manually or use some of the strategies to place the annotations (e.g., place tabs in a spacing or in given number along edges). Note that the strategies often need a properly build partition line. Once you are finished, you can render the tabs using <code>Panel.buildTabsFromAnnotations</code>. This function will merge the tab bodies and returns a list of cuts. With the list of cuts, you can further decide whether to ignore them or render them via mousebites or V-cuts. For more details on the automated process of building tabs from annotations, see understanding tabs.</p> <p>The document understanding tabs also explains what is a partition line and how it is used. Let us add that partition line is represented as shapely collection of line strings. The partition line is not a single one for the whole panel, but it is stored separately for each appended board as the annotations are rendered independently for each appended board.</p> <p>Also note that you can use the partition line as guide when placing features (e.g., adding a holes on backbone, etc.).</p>"},{"location":"panelization/scripting/#appending-boards","title":"Appending Boards","text":"<p>The simples approach to adding boards to a panel is using <code>Panel.appendBoard</code>. This places a board in the panel and also, it renames the nets such that they are panel-wise unique. This is necessary to pass DRC. You can specify the renaming pattern if you want. The substrate of the board is added the panel substrate, but it is also stored separately in <code>Panel.substrates</code> as the shape of the original board can be used to generate the automatic tabs and also it is used to copper-fill the non-board areas of the panel. You can also use these substrates to build your custom features.</p> <p>If you make single-board panels, you can use the function <code>Panel.makeGrid</code> to quickly place the boards in a grid. The function returns the list of individual substrates. You can use the substrates e.g., to build custom tabs or other features.</p>"},{"location":"panelization/tabs/","title":"How are tabs in KiKit created?","text":"<p>When you place multiple PCB into the panel, KiKit expects you to generate a so-called partition line for each individual PCB. Partition line is an oriented (poly)line that partitions the free space between the PCBs. It gives you the information \"this part of the free space belongs to this PCB substrate and this PCB is responsible for placing tabs in that space\". So for a regular input the partition line can look like this:</p> <p></p> <p>For more complicated input, it can look like this:</p> <p></p> <p>Note several facts: - partition line is used for backbone generator - partition line is not generated automatically, it is up to the user to   generate it. KiKit offers <code>Panel.buildPartitionLineFromBB</code> that builds the   partition line based on bounding boxes. If you need possibly a more   complicated lines, you have to implement them by yourself. - partition line is used for deciding if an annotation yields a tab or not - if   the tab does not hit the partition line, it is not created. - when we create partition line from bounding boxes, we include \"ghost   substrates\" representing the framing, that will be added in the future.</p> <p>When KiKit generates a tab, it generates it based on tab origin, direction and optionally the partition line. When a tab is successfully generated, it consists out of two components - a piece of a substrate (which will be later appended to the panel) and a cut-line.</p> <p>So assume we have the following PCB outline (the PCB is below the line, there is a free space above the line):</p> <p></p> <p>Then you specify your tab origin and its direction:</p> <p></p> <p>This is your input (e.g., via an annotation). Now KiKit does its job; it shoots two rays <code>tabWidth</code> apart and looks for the intersection with existing substrates. Note that if the ray starts within the PCB, no intersection will be found.</p> <p></p> <p>Once we have the intersections, we can easily generate the tab substrate and the cut:</p> <p></p> <p>Note that if we specify a partition line, than we shoot new rays in the opposite direction and try to hit the line. If we manage to do so, we get a tab. Otherwise, no tab is generated.</p> <p></p> <p>This is the basic algorithm for generating tabs. Well, we might also call them \"half tabs\". KiKit usually generates the half tabs around the board bounding box and then expects that two half tabs in the middle of the panel will merge into a single one. Also, KiKit first generates all the tabs and then merges them in one step to the board substrate. The cut is just a polyline which is in later steps either rendered as a V-cut or via mousebites.</p>"}]}